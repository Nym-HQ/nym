// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  Date: any
}

export type AddBookmarkInput = {
  tag?: InputMaybe<Scalars['String']>
  url: Scalars['String']
}

export type AddPageInput = {
  data: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  featured?: InputMaybe<Scalars['Boolean']>
  path: Scalars['String']
  slug: Scalars['String']
  text: Scalars['String']
  title: Scalars['String']
}

export type AddPostInput = {
  data: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  slug: Scalars['String']
  text: Scalars['String']
  title: Scalars['String']
}

export type AddQuestionInput = {
  description?: InputMaybe<Scalars['String']>
  title: Scalars['String']
}

export type AddSiteInput = {
  subdomain: Scalars['String']
}

export type Bookmark = {
  __typename?: 'Bookmark'
  createdAt: Scalars['Date']
  description?: Maybe<Scalars['String']>
  faviconUrl?: Maybe<Scalars['String']>
  host: Scalars['String']
  id: Scalars['ID']
  image?: Maybe<Scalars['String']>
  reactionCount?: Maybe<Scalars['Int']>
  tags: Array<Maybe<Tag>>
  title?: Maybe<Scalars['String']>
  updatedAt: Scalars['Date']
  url: Scalars['String']
  viewerHasReacted?: Maybe<Scalars['Boolean']>
}

export type BookmarkEdge = {
  __typename?: 'BookmarkEdge'
  cursor?: Maybe<Scalars['String']>
  node?: Maybe<Bookmark>
}

export type BookmarkFilter = {
  host?: InputMaybe<Scalars['String']>
  tag?: InputMaybe<Scalars['String']>
}

export type BookmarksConnection = {
  __typename?: 'BookmarksConnection'
  edges: Array<Maybe<BookmarkEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Comment = {
  __typename?: 'Comment'
  author: User
  createdAt: Scalars['Date']
  id: Scalars['ID']
  text?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['Date']>
  viewerCanDelete?: Maybe<Scalars['Boolean']>
  viewerCanEdit?: Maybe<Scalars['Boolean']>
}

export enum CommentType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
}

export type EditBookmarkInput = {
  description?: InputMaybe<Scalars['String']>
  faviconUrl?: InputMaybe<Scalars['String']>
  tag?: InputMaybe<Scalars['String']>
  title: Scalars['String']
}

export type EditPageInput = {
  data: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  featured?: InputMaybe<Scalars['Boolean']>
  path: Scalars['String']
  published?: InputMaybe<Scalars['Boolean']>
  publishedAt?: InputMaybe<Scalars['Date']>
  slug: Scalars['String']
  text: Scalars['String']
  title: Scalars['String']
}

export type EditPostInput = {
  data: Scalars['String']
  excerpt?: InputMaybe<Scalars['String']>
  publishNewsletter?: InputMaybe<Scalars['Boolean']>
  published?: InputMaybe<Scalars['Boolean']>
  publishedAt?: InputMaybe<Scalars['Date']>
  slug: Scalars['String']
  text: Scalars['String']
  title: Scalars['String']
}

export type EditQuestionInput = {
  description?: InputMaybe<Scalars['String']>
  title: Scalars['String']
}

export type EditSiteDomainInput = {
  parkedDomain: Scalars['String']
}

export type EditSiteInput = {
  attach_css?: InputMaybe<Scalars['String']>
  attach_js?: InputMaybe<Scalars['String']>
  banner?: InputMaybe<Scalars['String']>
  description?: InputMaybe<Scalars['String']>
  logo?: InputMaybe<Scalars['String']>
  name?: InputMaybe<Scalars['String']>
  newsletter_description?: InputMaybe<Scalars['String']>
  newsletter_double_optin?: InputMaybe<Scalars['Boolean']>
  newsletter_provider?: InputMaybe<Scalars['String']>
  newsletter_setting1?: InputMaybe<Scalars['String']>
  newsletter_setting2?: InputMaybe<Scalars['String']>
  newsletter_setting3?: InputMaybe<Scalars['String']>
  social_github?: InputMaybe<Scalars['String']>
  social_other1?: InputMaybe<Scalars['String']>
  social_other1_label?: InputMaybe<Scalars['String']>
  social_twitter?: InputMaybe<Scalars['String']>
  social_youtube?: InputMaybe<Scalars['String']>
}

export type EditUserInput = {
  email?: InputMaybe<Scalars['String']>
  username?: InputMaybe<Scalars['String']>
}

export type EmailSubscription = {
  __typename?: 'EmailSubscription'
  email?: Maybe<Scalars['String']>
  id: Scalars['ID']
  type?: Maybe<EmailSubscriptionType>
  userId?: Maybe<Scalars['String']>
}

export type EmailSubscriptionEdge = {
  __typename?: 'EmailSubscriptionEdge'
  cursor?: Maybe<Scalars['String']>
  node?: Maybe<EmailSubscription>
}

export type EmailSubscriptionInput = {
  email?: InputMaybe<Scalars['String']>
  subscribed: Scalars['Boolean']
  type: EmailSubscriptionType
}

export enum EmailSubscriptionType {
  Newsletter = 'NEWSLETTER',
}

export type EmailSubscriptionsConnection = {
  __typename?: 'EmailSubscriptionsConnection'
  edges: Array<Maybe<EmailSubscriptionEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Mutation = {
  __typename?: 'Mutation'
  addBookmark?: Maybe<Bookmark>
  addComment?: Maybe<Comment>
  addPage?: Maybe<Page>
  addPost?: Maybe<Post>
  addQuestion?: Maybe<Question>
  addSite?: Maybe<Site>
  deleteBookmark?: Maybe<Scalars['Boolean']>
  deleteComment?: Maybe<Scalars['Boolean']>
  deletePage?: Maybe<Scalars['Boolean']>
  deletePost?: Maybe<Scalars['Boolean']>
  deleteQuestion?: Maybe<Scalars['Boolean']>
  deleteSite?: Maybe<Scalars['Boolean']>
  deleteUser?: Maybe<Scalars['Boolean']>
  editBookmark?: Maybe<Bookmark>
  editComment?: Maybe<Comment>
  editEmailSubscription?: Maybe<User>
  editPage?: Maybe<Page>
  editPost?: Maybe<Post>
  editQuestion?: Maybe<Question>
  editSite?: Maybe<Site>
  editSiteDomain?: Maybe<Site>
  editUser?: Maybe<User>
  toggleReaction?: Maybe<Reactable>
}

export type MutationAddBookmarkArgs = {
  data: AddBookmarkInput
}

export type MutationAddCommentArgs = {
  refId: Scalars['ID']
  text: Scalars['String']
  type: CommentType
}

export type MutationAddPageArgs = {
  data: AddPageInput
}

export type MutationAddPostArgs = {
  data: AddPostInput
}

export type MutationAddQuestionArgs = {
  data: AddQuestionInput
}

export type MutationAddSiteArgs = {
  data: AddSiteInput
}

export type MutationDeleteBookmarkArgs = {
  id: Scalars['ID']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['ID']
}

export type MutationDeletePageArgs = {
  id: Scalars['ID']
}

export type MutationDeletePostArgs = {
  id: Scalars['ID']
}

export type MutationDeleteQuestionArgs = {
  id: Scalars['ID']
}

export type MutationDeleteSiteArgs = {
  subdomain: Scalars['String']
}

export type MutationEditBookmarkArgs = {
  data: EditBookmarkInput
  id: Scalars['ID']
}

export type MutationEditCommentArgs = {
  id: Scalars['ID']
  text?: InputMaybe<Scalars['String']>
}

export type MutationEditEmailSubscriptionArgs = {
  data?: InputMaybe<EmailSubscriptionInput>
}

export type MutationEditPageArgs = {
  data: EditPageInput
  id: Scalars['ID']
}

export type MutationEditPostArgs = {
  data: EditPostInput
  id: Scalars['ID']
}

export type MutationEditQuestionArgs = {
  data: EditQuestionInput
  id: Scalars['ID']
}

export type MutationEditSiteArgs = {
  data: EditSiteInput
  subdomain: Scalars['String']
}

export type MutationEditSiteDomainArgs = {
  data: EditSiteDomainInput
  subdomain: Scalars['String']
}

export type MutationEditUserArgs = {
  data?: InputMaybe<EditUserInput>
}

export type MutationToggleReactionArgs = {
  refId: Scalars['ID']
  type: ReactionType
}

export type Page = {
  __typename?: 'Page'
  author?: Maybe<User>
  createdAt?: Maybe<Scalars['Date']>
  data?: Maybe<Scalars['String']>
  excerpt?: Maybe<Scalars['String']>
  featureImage?: Maybe<Scalars['String']>
  featured?: Maybe<Scalars['Boolean']>
  id: Scalars['ID']
  path?: Maybe<Scalars['String']>
  publishedAt?: Maybe<Scalars['Date']>
  slug?: Maybe<Scalars['String']>
  text?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['Date']>
}

export type PageInfo = {
  __typename?: 'PageInfo'
  endCursor?: Maybe<Scalars['String']>
  hasNextPage?: Maybe<Scalars['Boolean']>
  totalCount?: Maybe<Scalars['Int']>
}

export type PagesFilter = {
  featuredOnly?: InputMaybe<Scalars['Boolean']>
  includeHomepage?: InputMaybe<Scalars['Boolean']>
  published?: InputMaybe<Scalars['Boolean']>
}

export type Post = {
  __typename?: 'Post'
  author?: Maybe<User>
  createdAt?: Maybe<Scalars['Date']>
  data?: Maybe<Scalars['String']>
  excerpt?: Maybe<Scalars['String']>
  featureImage?: Maybe<Scalars['String']>
  id: Scalars['ID']
  newsletterAt?: Maybe<Scalars['Date']>
  publishedAt?: Maybe<Scalars['Date']>
  reactionCount?: Maybe<Scalars['Int']>
  slug?: Maybe<Scalars['String']>
  text?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['Date']>
  viewerHasReacted?: Maybe<Scalars['Boolean']>
}

export type Query = {
  __typename?: 'Query'
  bookmark?: Maybe<Bookmark>
  bookmarks: BookmarksConnection
  comment?: Maybe<Comment>
  comments: Array<Maybe<Comment>>
  context: ViewerContext
  emailSubscriptions: EmailSubscriptionsConnection
  homepage?: Maybe<Page>
  page?: Maybe<Page>
  pages: Array<Maybe<Page>>
  post?: Maybe<Post>
  posts: Array<Maybe<Post>>
  question?: Maybe<Question>
  questions: QuestionsConnection
  tags: Array<Maybe<Tag>>
  user?: Maybe<User>
  userSites?: Maybe<Array<UserSite>>
}

export type QueryBookmarkArgs = {
  id: Scalars['ID']
}

export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<BookmarkFilter>
  first?: InputMaybe<Scalars['Int']>
}

export type QueryCommentArgs = {
  id: Scalars['ID']
}

export type QueryCommentsArgs = {
  refId: Scalars['ID']
  type: CommentType
}

export type QueryEmailSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']>
  first?: InputMaybe<Scalars['Int']>
}

export type QueryPageArgs = {
  slug: Scalars['String']
}

export type QueryPagesArgs = {
  filter?: InputMaybe<PagesFilter>
}

export type QueryPostArgs = {
  slug: Scalars['String']
}

export type QueryPostsArgs = {
  filter?: InputMaybe<WritingFilter>
}

export type QueryQuestionArgs = {
  id: Scalars['ID']
}

export type QueryQuestionsArgs = {
  after?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<QuestionFilter>
  first?: InputMaybe<Scalars['Int']>
}

export type QueryUserArgs = {
  username: Scalars['String']
}

export type Question = {
  __typename?: 'Question'
  author?: Maybe<User>
  createdAt: Scalars['Date']
  description?: Maybe<Scalars['String']>
  id: Scalars['ID']
  reactionCount?: Maybe<Scalars['Int']>
  status?: Maybe<QuestionStatus>
  title: Scalars['String']
  updatedAt?: Maybe<Scalars['Date']>
  viewerCanComment?: Maybe<Scalars['Boolean']>
  viewerCanEdit?: Maybe<Scalars['Boolean']>
  viewerHasReacted?: Maybe<Scalars['Boolean']>
}

export type QuestionEdge = {
  __typename?: 'QuestionEdge'
  cursor?: Maybe<Scalars['String']>
  node?: Maybe<Question>
}

export type QuestionFilter = {
  status?: InputMaybe<QuestionStatus>
}

export enum QuestionStatus {
  Answered = 'ANSWERED',
  Pending = 'PENDING',
}

export type QuestionsConnection = {
  __typename?: 'QuestionsConnection'
  edges: Array<Maybe<QuestionEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Reactable = Bookmark | Post | Question

export enum ReactionType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
}

export type Site = {
  __typename?: 'Site'
  attach_css?: Maybe<Scalars['String']>
  attach_js?: Maybe<Scalars['String']>
  banner?: Maybe<Scalars['String']>
  description?: Maybe<Scalars['String']>
  id: Scalars['ID']
  logo?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  newsletter_description?: Maybe<Scalars['String']>
  newsletter_double_optin?: Maybe<Scalars['Boolean']>
  newsletter_provider?: Maybe<Scalars['String']>
  newsletter_setting1?: Maybe<Scalars['String']>
  newsletter_setting2?: Maybe<Scalars['String']>
  newsletter_setting3?: Maybe<Scalars['String']>
  parkedDomain?: Maybe<Scalars['String']>
  plan?: Maybe<Scalars['String']>
  social_github?: Maybe<Scalars['String']>
  social_other1?: Maybe<Scalars['String']>
  social_other1_label?: Maybe<Scalars['String']>
  social_twitter?: Maybe<Scalars['String']>
  social_youtube?: Maybe<Scalars['String']>
  subdomain?: Maybe<Scalars['String']>
}

export type SiteOwner = {
  __typename?: 'SiteOwner'
  avatar?: Maybe<Scalars['String']>
  image?: Maybe<Scalars['String']>
}

export enum SiteRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  Owner = 'OWNER',
  User = 'USER',
}

export type Tag = {
  __typename?: 'Tag'
  name: Scalars['String']
}

export type User = {
  __typename?: 'User'
  avatar?: Maybe<Scalars['String']>
  createdAt?: Maybe<Scalars['Date']>
  description?: Maybe<Scalars['String']>
  email?: Maybe<Scalars['String']>
  emailSubscriptions?: Maybe<Array<Maybe<UserEmailSubscription>>>
  id: Scalars['ID']
  image?: Maybe<Scalars['String']>
  isAdmin?: Maybe<Scalars['Boolean']>
  location?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  pendingEmail?: Maybe<Scalars['String']>
  role?: Maybe<UserRole>
  social_github?: Maybe<Scalars['String']>
  social_other1?: Maybe<Scalars['String']>
  social_other1_label?: Maybe<Scalars['String']>
  social_twitter?: Maybe<Scalars['String']>
  social_youtube?: Maybe<Scalars['String']>
  username?: Maybe<Scalars['String']>
}

export type UserEmailSubscription = {
  __typename?: 'UserEmailSubscription'
  subscribed?: Maybe<Scalars['Boolean']>
  type?: Maybe<EmailSubscriptionType>
}

export enum UserRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type UserSite = {
  __typename?: 'UserSite'
  id: Scalars['ID']
  site?: Maybe<Site>
  siteRole?: Maybe<SiteRole>
  userId?: Maybe<Scalars['String']>
}

export type ViewerContext = {
  __typename?: 'ViewerContext'
  owner?: Maybe<SiteOwner>
  site?: Maybe<Site>
  userSite?: Maybe<UserSite>
  viewer?: Maybe<User>
}

export type WritingFilter = {
  published?: InputMaybe<Scalars['Boolean']>
}

export type BookmarkCoreFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null | undefined
  description?: string | null | undefined
  faviconUrl?: string | null | undefined
}

export type BookmarkListItemFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null | undefined
  description?: string | null | undefined
  faviconUrl?: string | null | undefined
}

export type BookmarkDetailFragment = {
  __typename: 'Bookmark'
  reactionCount?: number | null | undefined
  viewerHasReacted?: boolean | null | undefined
  id: string
  url: string
  host: string
  title?: string | null | undefined
  description?: string | null | undefined
  faviconUrl?: string | null | undefined
  tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
}

export type BookmarksConnectionFragment = {
  __typename?: 'BookmarksConnection'
  pageInfo?:
    | {
        __typename?: 'PageInfo'
        hasNextPage?: boolean | null | undefined
        totalCount?: number | null | undefined
        endCursor?: string | null | undefined
      }
    | null
    | undefined
  edges: Array<
    | {
        __typename?: 'BookmarkEdge'
        cursor?: string | null | undefined
        node?:
          | {
              __typename: 'Bookmark'
              id: string
              url: string
              host: string
              title?: string | null | undefined
              description?: string | null | undefined
              faviconUrl?: string | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  >
}

export type CommentInfoFragment = {
  __typename: 'Comment'
  id: string
  createdAt: any
  updatedAt?: any | null | undefined
  text?: string | null | undefined
  viewerCanEdit?: boolean | null | undefined
  viewerCanDelete?: boolean | null | undefined
  author: {
    __typename: 'User'
    id: string
    username?: string | null | undefined
    image?: string | null | undefined
    avatar?: string | null | undefined
    name?: string | null | undefined
    role?: UserRole | null | undefined
    isAdmin?: boolean | null | undefined
  }
}

export type EmailSubscriptionDetailFragment = {
  __typename: 'EmailSubscription'
  id: string
  email?: string | null | undefined
  type?: EmailSubscriptionType | null | undefined
  userId?: string | null | undefined
}

export type EmailSubscriptionListItemFragment = {
  __typename: 'EmailSubscription'
  id: string
  email?: string | null | undefined
  type?: EmailSubscriptionType | null | undefined
  userId?: string | null | undefined
}

export type EmailSubscriptionsConnectionFragment = {
  __typename?: 'EmailSubscriptionsConnection'
  pageInfo?:
    | {
        __typename?: 'PageInfo'
        hasNextPage?: boolean | null | undefined
        totalCount?: number | null | undefined
        endCursor?: string | null | undefined
      }
    | null
    | undefined
  edges: Array<
    | {
        __typename?: 'EmailSubscriptionEdge'
        cursor?: string | null | undefined
        node?:
          | {
              __typename: 'EmailSubscription'
              id: string
              email?: string | null | undefined
              type?: EmailSubscriptionType | null | undefined
              userId?: string | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  >
}

export type PageCoreFragment = {
  __typename: 'Page'
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  path?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
  featured?: boolean | null | undefined
}

export type PageListItemFragment = {
  __typename: 'Page'
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  path?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
  featured?: boolean | null | undefined
}

export type PageDetailFragment = {
  __typename: 'Page'
  text?: string | null | undefined
  data?: string | null | undefined
  featureImage?: string | null | undefined
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  path?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
  featured?: boolean | null | undefined
}

export type PostCoreFragment = {
  __typename: 'Post'
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
}

export type PostListItemFragment = {
  __typename: 'Post'
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
}

export type PostDetailFragment = {
  __typename: 'Post'
  text?: string | null | undefined
  data?: string | null | undefined
  featureImage?: string | null | undefined
  reactionCount?: number | null | undefined
  viewerHasReacted?: boolean | null | undefined
  newsletterAt?: any | null | undefined
  id: string
  publishedAt?: any | null | undefined
  title?: string | null | undefined
  slug?: string | null | undefined
  excerpt?: string | null | undefined
}

export type QuestionCoreFragment = {
  __typename: 'Question'
  id: string
  title: string
  createdAt: any
  author?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        image?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isAdmin?: boolean | null | undefined
      }
    | null
    | undefined
}

export type QuestionListItemFragment = {
  __typename: 'Question'
  id: string
  title: string
  createdAt: any
  author?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        image?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isAdmin?: boolean | null | undefined
      }
    | null
    | undefined
}

export type QuestionDetailFragment = {
  __typename: 'Question'
  description?: string | null | undefined
  status?: QuestionStatus | null | undefined
  viewerCanEdit?: boolean | null | undefined
  viewerCanComment?: boolean | null | undefined
  reactionCount?: number | null | undefined
  viewerHasReacted?: boolean | null | undefined
  id: string
  title: string
  createdAt: any
  author?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        image?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isAdmin?: boolean | null | undefined
      }
    | null
    | undefined
}

export type QuestionsConnectionFragment = {
  __typename?: 'QuestionsConnection'
  pageInfo?:
    | {
        __typename?: 'PageInfo'
        hasNextPage?: boolean | null | undefined
        totalCount?: number | null | undefined
        endCursor?: string | null | undefined
      }
    | null
    | undefined
  edges: Array<
    | {
        __typename?: 'QuestionEdge'
        cursor?: string | null | undefined
        node?:
          | {
              __typename: 'Question'
              id: string
              title: string
              createdAt: any
              author?:
                | {
                    __typename: 'User'
                    id: string
                    username?: string | null | undefined
                    image?: string | null | undefined
                    avatar?: string | null | undefined
                    name?: string | null | undefined
                    role?: UserRole | null | undefined
                    isAdmin?: boolean | null | undefined
                  }
                | null
                | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  >
}

export type SiteInfoFragment = {
  __typename: 'Site'
  id: string
  subdomain?: string | null | undefined
  parkedDomain?: string | null | undefined
  plan?: string | null | undefined
  name?: string | null | undefined
  description?: string | null | undefined
  logo?: string | null | undefined
  banner?: string | null | undefined
  attach_css?: string | null | undefined
  attach_js?: string | null | undefined
  newsletter_provider?: string | null | undefined
  newsletter_description?: string | null | undefined
  newsletter_double_optin?: boolean | null | undefined
  newsletter_setting1?: string | null | undefined
  newsletter_setting2?: string | null | undefined
  newsletter_setting3?: string | null | undefined
  social_twitter?: string | null | undefined
  social_youtube?: string | null | undefined
  social_github?: string | null | undefined
  social_other1?: string | null | undefined
  social_other1_label?: string | null | undefined
}

export type UserSiteFragment = {
  __typename?: 'UserSite'
  id: string
  userId?: string | null | undefined
  siteRole?: SiteRole | null | undefined
  site?: { __typename?: 'Site'; id: string } | null | undefined
}

export type UserSiteInfoFragment = {
  __typename?: 'UserSite'
  id: string
  userId?: string | null | undefined
  siteRole?: SiteRole | null | undefined
  site?:
    | {
        __typename: 'Site'
        id: string
        subdomain?: string | null | undefined
        parkedDomain?: string | null | undefined
        plan?: string | null | undefined
        name?: string | null | undefined
        description?: string | null | undefined
        logo?: string | null | undefined
        banner?: string | null | undefined
        attach_css?: string | null | undefined
        attach_js?: string | null | undefined
        newsletter_provider?: string | null | undefined
        newsletter_description?: string | null | undefined
        newsletter_double_optin?: boolean | null | undefined
        newsletter_setting1?: string | null | undefined
        newsletter_setting2?: string | null | undefined
        newsletter_setting3?: string | null | undefined
        social_twitter?: string | null | undefined
        social_youtube?: string | null | undefined
        social_github?: string | null | undefined
        social_other1?: string | null | undefined
        social_other1_label?: string | null | undefined
      }
    | null
    | undefined
}

export type UserInfoFragment = {
  __typename: 'User'
  id: string
  username?: string | null | undefined
  image?: string | null | undefined
  avatar?: string | null | undefined
  name?: string | null | undefined
  role?: UserRole | null | undefined
  isAdmin?: boolean | null | undefined
}

export type UserSettingsFragment = {
  __typename?: 'User'
  email?: string | null | undefined
  pendingEmail?: string | null | undefined
  emailSubscriptions?:
    | Array<
        | {
            __typename?: 'UserEmailSubscription'
            type?: EmailSubscriptionType | null | undefined
            subscribed?: boolean | null | undefined
          }
        | null
        | undefined
      >
    | null
    | undefined
}

export type EditBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditBookmarkInput
}>

export type EditBookmarkMutation = {
  __typename?: 'Mutation'
  editBookmark?:
    | {
        __typename: 'Bookmark'
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type DeleteBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteBookmarkMutation = {
  __typename?: 'Mutation'
  deleteBookmark?: boolean | null | undefined
}

export type AddBookmarkMutationVariables = Exact<{
  data: AddBookmarkInput
}>

export type AddBookmarkMutation = {
  __typename?: 'Mutation'
  addBookmark?:
    | {
        __typename: 'Bookmark'
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type AddCommentMutationVariables = Exact<{
  refId: Scalars['ID']
  type: CommentType
  text: Scalars['String']
}>

export type AddCommentMutation = {
  __typename?: 'Mutation'
  addComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: any
        updatedAt?: any | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          image?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isAdmin?: boolean | null | undefined
        }
      }
    | null
    | undefined
}

export type EditCommentMutationVariables = Exact<{
  id: Scalars['ID']
  text: Scalars['String']
}>

export type EditCommentMutation = {
  __typename?: 'Mutation'
  editComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: any
        updatedAt?: any | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          image?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isAdmin?: boolean | null | undefined
        }
      }
    | null
    | undefined
}

export type DeleteCommentMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteCommentMutation = {
  __typename?: 'Mutation'
  deleteComment?: boolean | null | undefined
}

export type EditEmailSubscriptionMutationVariables = Exact<{
  data?: InputMaybe<EmailSubscriptionInput>
}>

export type EditEmailSubscriptionMutation = {
  __typename?: 'Mutation'
  editEmailSubscription?:
    | {
        __typename?: 'User'
        emailSubscriptions?:
          | Array<
              | {
                  __typename?: 'UserEmailSubscription'
                  subscribed?: boolean | null | undefined
                  type?: EmailSubscriptionType | null | undefined
                }
              | null
              | undefined
            >
          | null
          | undefined
      }
    | null
    | undefined
}

export type EditPageMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditPageInput
}>

export type EditPageMutation = {
  __typename?: 'Mutation'
  editPage?:
    | {
        __typename: 'Page'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        path?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
        featured?: boolean | null | undefined
      }
    | null
    | undefined
}

export type DeletePageMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeletePageMutation = {
  __typename?: 'Mutation'
  deletePage?: boolean | null | undefined
}

export type AddPageMutationVariables = Exact<{
  data: AddPageInput
}>

export type AddPageMutation = {
  __typename?: 'Mutation'
  addPage?:
    | {
        __typename: 'Page'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        path?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
        featured?: boolean | null | undefined
      }
    | null
    | undefined
}

export type EditPostMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditPostInput
}>

export type EditPostMutation = {
  __typename?: 'Mutation'
  editPost?:
    | {
        __typename: 'Post'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        newsletterAt?: any | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
      }
    | null
    | undefined
}

export type DeletePostMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeletePostMutation = {
  __typename?: 'Mutation'
  deletePost?: boolean | null | undefined
}

export type AddPostMutationVariables = Exact<{
  data: AddPostInput
}>

export type AddPostMutation = {
  __typename?: 'Mutation'
  addPost?:
    | {
        __typename: 'Post'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        newsletterAt?: any | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
      }
    | null
    | undefined
}

export type EditQuestionMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditQuestionInput
}>

export type EditQuestionMutation = {
  __typename?: 'Mutation'
  editQuestion?:
    | {
        __typename: 'Question'
        description?: string | null | undefined
        status?: QuestionStatus | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanComment?: boolean | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        title: string
        createdAt: any
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              image?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isAdmin?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type DeleteQuestionMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteQuestionMutation = {
  __typename?: 'Mutation'
  deleteQuestion?: boolean | null | undefined
}

export type AddQuestionMutationVariables = Exact<{
  data: AddQuestionInput
}>

export type AddQuestionMutation = {
  __typename?: 'Mutation'
  addQuestion?:
    | {
        __typename: 'Question'
        description?: string | null | undefined
        status?: QuestionStatus | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanComment?: boolean | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        title: string
        createdAt: any
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              image?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isAdmin?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type ToggleReactionMutationVariables = Exact<{
  refId: Scalars['ID']
  type: ReactionType
}>

export type ToggleReactionMutation = {
  __typename?: 'Mutation'
  toggleReaction?:
    | {
        __typename?: 'Bookmark'
        id: string
        url: string
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
      }
    | {
        __typename?: 'Post'
        id: string
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
      }
    | {
        __typename?: 'Question'
        id: string
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
      }
    | null
    | undefined
}

export type EditSiteDomainMutationVariables = Exact<{
  subdomain: Scalars['String']
  data: EditSiteDomainInput
}>

export type EditSiteDomainMutation = {
  __typename?: 'Mutation'
  editSiteDomain?:
    | {
        __typename: 'Site'
        id: string
        subdomain?: string | null | undefined
        parkedDomain?: string | null | undefined
        plan?: string | null | undefined
        name?: string | null | undefined
        description?: string | null | undefined
        logo?: string | null | undefined
        banner?: string | null | undefined
        attach_css?: string | null | undefined
        attach_js?: string | null | undefined
        newsletter_provider?: string | null | undefined
        newsletter_description?: string | null | undefined
        newsletter_double_optin?: boolean | null | undefined
        newsletter_setting1?: string | null | undefined
        newsletter_setting2?: string | null | undefined
        newsletter_setting3?: string | null | undefined
        social_twitter?: string | null | undefined
        social_youtube?: string | null | undefined
        social_github?: string | null | undefined
        social_other1?: string | null | undefined
        social_other1_label?: string | null | undefined
      }
    | null
    | undefined
}

export type EditSiteMutationVariables = Exact<{
  subdomain: Scalars['String']
  data: EditSiteInput
}>

export type EditSiteMutation = {
  __typename?: 'Mutation'
  editSite?:
    | {
        __typename: 'Site'
        id: string
        subdomain?: string | null | undefined
        parkedDomain?: string | null | undefined
        plan?: string | null | undefined
        name?: string | null | undefined
        description?: string | null | undefined
        logo?: string | null | undefined
        banner?: string | null | undefined
        attach_css?: string | null | undefined
        attach_js?: string | null | undefined
        newsletter_provider?: string | null | undefined
        newsletter_description?: string | null | undefined
        newsletter_double_optin?: boolean | null | undefined
        newsletter_setting1?: string | null | undefined
        newsletter_setting2?: string | null | undefined
        newsletter_setting3?: string | null | undefined
        social_twitter?: string | null | undefined
        social_youtube?: string | null | undefined
        social_github?: string | null | undefined
        social_other1?: string | null | undefined
        social_other1_label?: string | null | undefined
      }
    | null
    | undefined
}

export type DeleteSiteMutationVariables = Exact<{
  subdomain: Scalars['String']
}>

export type DeleteSiteMutation = {
  __typename?: 'Mutation'
  deleteSite?: boolean | null | undefined
}

export type AddSiteMutationVariables = Exact<{
  data: AddSiteInput
}>

export type AddSiteMutation = {
  __typename?: 'Mutation'
  addSite?:
    | {
        __typename: 'Site'
        id: string
        subdomain?: string | null | undefined
        parkedDomain?: string | null | undefined
        plan?: string | null | undefined
        name?: string | null | undefined
        description?: string | null | undefined
        logo?: string | null | undefined
        banner?: string | null | undefined
        attach_css?: string | null | undefined
        attach_js?: string | null | undefined
        newsletter_provider?: string | null | undefined
        newsletter_description?: string | null | undefined
        newsletter_double_optin?: boolean | null | undefined
        newsletter_setting1?: string | null | undefined
        newsletter_setting2?: string | null | undefined
        newsletter_setting3?: string | null | undefined
        social_twitter?: string | null | undefined
        social_youtube?: string | null | undefined
        social_github?: string | null | undefined
        social_other1?: string | null | undefined
        social_other1_label?: string | null | undefined
      }
    | null
    | undefined
}

export type DeleteUserMutationVariables = Exact<{ [key: string]: never }>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: boolean | null | undefined
}

export type EditUserMutationVariables = Exact<{
  data?: InputMaybe<EditUserInput>
}>

export type EditUserMutation = {
  __typename?: 'Mutation'
  editUser?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        image?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isAdmin?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetBookmarksQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>
  after?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<BookmarkFilter>
}>

export type GetBookmarksQuery = {
  __typename?: 'Query'
  bookmarks: {
    __typename?: 'BookmarksConnection'
    pageInfo?:
      | {
          __typename?: 'PageInfo'
          hasNextPage?: boolean | null | undefined
          totalCount?: number | null | undefined
          endCursor?: string | null | undefined
        }
      | null
      | undefined
    edges: Array<
      | {
          __typename?: 'BookmarkEdge'
          cursor?: string | null | undefined
          node?:
            | {
                __typename: 'Bookmark'
                id: string
                url: string
                host: string
                title?: string | null | undefined
                description?: string | null | undefined
                faviconUrl?: string | null | undefined
              }
            | null
            | undefined
        }
      | null
      | undefined
    >
  }
}

export type GetBookmarkQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetBookmarkQuery = {
  __typename?: 'Query'
  bookmark?:
    | {
        __typename: 'Bookmark'
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type GetCommentsQueryVariables = Exact<{
  refId: Scalars['ID']
  type: CommentType
}>

export type GetCommentsQuery = {
  __typename?: 'Query'
  comments: Array<
    | {
        __typename: 'Comment'
        id: string
        createdAt: any
        updatedAt?: any | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          image?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isAdmin?: boolean | null | undefined
        }
      }
    | null
    | undefined
  >
}

export type GetEmailSubscriptionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>
  after?: InputMaybe<Scalars['String']>
}>

export type GetEmailSubscriptionsQuery = {
  __typename?: 'Query'
  emailSubscriptions: {
    __typename?: 'EmailSubscriptionsConnection'
    pageInfo?:
      | {
          __typename?: 'PageInfo'
          hasNextPage?: boolean | null | undefined
          totalCount?: number | null | undefined
          endCursor?: string | null | undefined
        }
      | null
      | undefined
    edges: Array<
      | {
          __typename?: 'EmailSubscriptionEdge'
          cursor?: string | null | undefined
          node?:
            | {
                __typename: 'EmailSubscription'
                id: string
                email?: string | null | undefined
                type?: EmailSubscriptionType | null | undefined
                userId?: string | null | undefined
              }
            | null
            | undefined
        }
      | null
      | undefined
    >
  }
}

export type GetPagesQueryVariables = Exact<{
  filter?: InputMaybe<PagesFilter>
}>

export type GetPagesQuery = {
  __typename?: 'Query'
  pages: Array<
    | {
        __typename: 'Page'
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        path?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
        featured?: boolean | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPageQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPageQuery = {
  __typename?: 'Query'
  page?:
    | {
        __typename: 'Page'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        path?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
        featured?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetHomePageQueryVariables = Exact<{ [key: string]: never }>

export type GetHomePageQuery = {
  __typename?: 'Query'
  homepage?:
    | {
        __typename: 'Page'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        path?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
        featured?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetPostsQueryVariables = Exact<{
  filter?: InputMaybe<WritingFilter>
}>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts: Array<
    | {
        __typename: 'Post'
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?:
    | {
        __typename: 'Post'
        text?: string | null | undefined
        data?: string | null | undefined
        featureImage?: string | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        newsletterAt?: any | null | undefined
        id: string
        publishedAt?: any | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        excerpt?: string | null | undefined
      }
    | null
    | undefined
}

export type GetQuestionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>
  after?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<QuestionFilter>
}>

export type GetQuestionsQuery = {
  __typename?: 'Query'
  questions: {
    __typename?: 'QuestionsConnection'
    pageInfo?:
      | {
          __typename?: 'PageInfo'
          hasNextPage?: boolean | null | undefined
          totalCount?: number | null | undefined
          endCursor?: string | null | undefined
        }
      | null
      | undefined
    edges: Array<
      | {
          __typename?: 'QuestionEdge'
          cursor?: string | null | undefined
          node?:
            | {
                __typename: 'Question'
                id: string
                title: string
                createdAt: any
                author?:
                  | {
                      __typename: 'User'
                      id: string
                      username?: string | null | undefined
                      image?: string | null | undefined
                      avatar?: string | null | undefined
                      name?: string | null | undefined
                      role?: UserRole | null | undefined
                      isAdmin?: boolean | null | undefined
                    }
                  | null
                  | undefined
              }
            | null
            | undefined
        }
      | null
      | undefined
    >
  }
}

export type GetQuestionQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetQuestionQuery = {
  __typename?: 'Query'
  question?:
    | {
        __typename: 'Question'
        description?: string | null | undefined
        status?: QuestionStatus | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanComment?: boolean | null | undefined
        reactionCount?: number | null | undefined
        viewerHasReacted?: boolean | null | undefined
        id: string
        title: string
        createdAt: any
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              image?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isAdmin?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type GetSitesQueryVariables = Exact<{ [key: string]: never }>

export type GetSitesQuery = {
  __typename?: 'Query'
  userSites?:
    | Array<{
        __typename?: 'UserSite'
        id: string
        userId?: string | null | undefined
        siteRole?: SiteRole | null | undefined
        site?:
          | {
              __typename: 'Site'
              id: string
              subdomain?: string | null | undefined
              parkedDomain?: string | null | undefined
              plan?: string | null | undefined
              name?: string | null | undefined
              description?: string | null | undefined
              logo?: string | null | undefined
              banner?: string | null | undefined
              attach_css?: string | null | undefined
              attach_js?: string | null | undefined
              newsletter_provider?: string | null | undefined
              newsletter_description?: string | null | undefined
              newsletter_double_optin?: boolean | null | undefined
              newsletter_setting1?: string | null | undefined
              newsletter_setting2?: string | null | undefined
              newsletter_setting3?: string | null | undefined
              social_twitter?: string | null | undefined
              social_youtube?: string | null | undefined
              social_github?: string | null | undefined
              social_other1?: string | null | undefined
              social_other1_label?: string | null | undefined
            }
          | null
          | undefined
      }>
    | null
    | undefined
}

export type GetTagsQueryVariables = Exact<{ [key: string]: never }>

export type GetTagsQuery = {
  __typename?: 'Query'
  tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
}

export type GetUserQueryVariables = Exact<{
  username: Scalars['String']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        image?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isAdmin?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetViewerWithSettingsQueryVariables = Exact<{
  [key: string]: never
}>

export type GetViewerWithSettingsQuery = {
  __typename?: 'Query'
  context: {
    __typename?: 'ViewerContext'
    viewer?:
      | {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          image?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isAdmin?: boolean | null | undefined
          email?: string | null | undefined
          pendingEmail?: string | null | undefined
          emailSubscriptions?:
            | Array<
                | {
                    __typename?: 'UserEmailSubscription'
                    type?: EmailSubscriptionType | null | undefined
                    subscribed?: boolean | null | undefined
                  }
                | null
                | undefined
              >
            | null
            | undefined
        }
      | null
      | undefined
  }
}

export type ContextQueryVariables = Exact<{ [key: string]: never }>

export type ContextQuery = {
  __typename?: 'Query'
  context: {
    __typename?: 'ViewerContext'
    viewer?:
      | {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          image?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isAdmin?: boolean | null | undefined
        }
      | null
      | undefined
    site?:
      | {
          __typename: 'Site'
          id: string
          subdomain?: string | null | undefined
          parkedDomain?: string | null | undefined
          plan?: string | null | undefined
          name?: string | null | undefined
          description?: string | null | undefined
          logo?: string | null | undefined
          banner?: string | null | undefined
          attach_css?: string | null | undefined
          attach_js?: string | null | undefined
          newsletter_provider?: string | null | undefined
          newsletter_description?: string | null | undefined
          newsletter_double_optin?: boolean | null | undefined
          newsletter_setting1?: string | null | undefined
          newsletter_setting2?: string | null | undefined
          newsletter_setting3?: string | null | undefined
          social_twitter?: string | null | undefined
          social_youtube?: string | null | undefined
          social_github?: string | null | undefined
          social_other1?: string | null | undefined
          social_other1_label?: string | null | undefined
        }
      | null
      | undefined
    userSite?:
      | {
          __typename?: 'UserSite'
          id: string
          userId?: string | null | undefined
          siteRole?: SiteRole | null | undefined
          site?: { __typename?: 'Site'; id: string } | null | undefined
        }
      | null
      | undefined
    owner?:
      | {
          __typename?: 'SiteOwner'
          image?: string | null | undefined
          avatar?: string | null | undefined
        }
      | null
      | undefined
  }
}

export const BookmarkCoreFragmentDoc = gql`
  fragment BookmarkCore on Bookmark {
    __typename
    id
    url
    host
    title
    description
    faviconUrl
  }
`
export const BookmarkDetailFragmentDoc = gql`
  fragment BookmarkDetail on Bookmark {
    ...BookmarkCore
    reactionCount
    viewerHasReacted
    tags {
      name
    }
  }
  ${BookmarkCoreFragmentDoc}
`
export const BookmarkListItemFragmentDoc = gql`
  fragment BookmarkListItem on Bookmark {
    ...BookmarkCore
  }
  ${BookmarkCoreFragmentDoc}
`
export const BookmarksConnectionFragmentDoc = gql`
  fragment BookmarksConnection on BookmarksConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...BookmarkListItem
      }
    }
  }
  ${BookmarkListItemFragmentDoc}
`
export const UserInfoFragmentDoc = gql`
  fragment UserInfo on User {
    __typename
    id
    username
    image
    avatar
    name
    role
    isAdmin
  }
`
export const CommentInfoFragmentDoc = gql`
  fragment CommentInfo on Comment {
    __typename
    id
    createdAt
    updatedAt
    text
    viewerCanEdit
    viewerCanDelete
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const EmailSubscriptionDetailFragmentDoc = gql`
  fragment EmailSubscriptionDetail on EmailSubscription {
    __typename
    id
    email
    type
    userId
  }
`
export const EmailSubscriptionListItemFragmentDoc = gql`
  fragment EmailSubscriptionListItem on EmailSubscription {
    ...EmailSubscriptionDetail
  }
  ${EmailSubscriptionDetailFragmentDoc}
`
export const EmailSubscriptionsConnectionFragmentDoc = gql`
  fragment EmailSubscriptionsConnection on EmailSubscriptionsConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...EmailSubscriptionListItem
      }
    }
  }
  ${EmailSubscriptionListItemFragmentDoc}
`
export const PageCoreFragmentDoc = gql`
  fragment PageCore on Page {
    __typename
    id
    publishedAt
    title
    path
    slug
    excerpt
    featured
  }
`
export const PageListItemFragmentDoc = gql`
  fragment PageListItem on Page {
    ...PageCore
  }
  ${PageCoreFragmentDoc}
`
export const PageDetailFragmentDoc = gql`
  fragment PageDetail on Page {
    ...PageCore
    text
    data
    featureImage
  }
  ${PageCoreFragmentDoc}
`
export const PostCoreFragmentDoc = gql`
  fragment PostCore on Post {
    __typename
    id
    publishedAt
    title
    slug
    excerpt
  }
`
export const PostListItemFragmentDoc = gql`
  fragment PostListItem on Post {
    ...PostCore
  }
  ${PostCoreFragmentDoc}
`
export const PostDetailFragmentDoc = gql`
  fragment PostDetail on Post {
    ...PostCore
    text
    data
    featureImage
    reactionCount
    viewerHasReacted
    newsletterAt
  }
  ${PostCoreFragmentDoc}
`
export const QuestionCoreFragmentDoc = gql`
  fragment QuestionCore on Question {
    __typename
    id
    title
    createdAt
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const QuestionDetailFragmentDoc = gql`
  fragment QuestionDetail on Question {
    ...QuestionCore
    description
    status
    viewerCanEdit
    viewerCanComment
    reactionCount
    viewerHasReacted
  }
  ${QuestionCoreFragmentDoc}
`
export const QuestionListItemFragmentDoc = gql`
  fragment QuestionListItem on Question {
    ...QuestionCore
  }
  ${QuestionCoreFragmentDoc}
`
export const QuestionsConnectionFragmentDoc = gql`
  fragment QuestionsConnection on QuestionsConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...QuestionListItem
      }
    }
  }
  ${QuestionListItemFragmentDoc}
`
export const UserSiteFragmentDoc = gql`
  fragment UserSite on UserSite {
    id
    userId
    siteRole
    site {
      id
    }
  }
`
export const SiteInfoFragmentDoc = gql`
  fragment SiteInfo on Site {
    __typename
    id
    subdomain
    parkedDomain
    plan
    name
    description
    logo
    banner
    attach_css
    attach_js
    newsletter_provider
    newsletter_description
    newsletter_double_optin
    newsletter_setting1
    newsletter_setting2
    newsletter_setting3
    social_twitter
    social_youtube
    social_github
    social_other1
    social_other1_label
  }
`
export const UserSiteInfoFragmentDoc = gql`
  fragment UserSiteInfo on UserSite {
    id
    userId
    siteRole
    site {
      ...SiteInfo
    }
  }
  ${SiteInfoFragmentDoc}
`
export const UserSettingsFragmentDoc = gql`
  fragment UserSettings on User {
    email
    pendingEmail
    emailSubscriptions {
      type
      subscribed
    }
  }
`
export const EditBookmarkDocument = gql`
  mutation editBookmark($id: ID!, $data: EditBookmarkInput!) {
    editBookmark(id: $id, data: $data) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`
export type EditBookmarkMutationFn = Apollo.MutationFunction<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>

/**
 * __useEditBookmarkMutation__
 *
 * To run a mutation, you first call `useEditBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookmarkMutation, { data, loading, error }] = useEditBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >(EditBookmarkDocument, options)
}
export type EditBookmarkMutationHookResult = ReturnType<
  typeof useEditBookmarkMutation
>
export type EditBookmarkMutationResult =
  Apollo.MutationResult<EditBookmarkMutation>
export type EditBookmarkMutationOptions = Apollo.BaseMutationOptions<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>
export const DeleteBookmarkDocument = gql`
  mutation deleteBookmark($id: ID!) {
    deleteBookmark(id: $id)
  }
`
export type DeleteBookmarkMutationFn = Apollo.MutationFunction<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>

/**
 * __useDeleteBookmarkMutation__
 *
 * To run a mutation, you first call `useDeleteBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookmarkMutation, { data, loading, error }] = useDeleteBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >(DeleteBookmarkDocument, options)
}
export type DeleteBookmarkMutationHookResult = ReturnType<
  typeof useDeleteBookmarkMutation
>
export type DeleteBookmarkMutationResult =
  Apollo.MutationResult<DeleteBookmarkMutation>
export type DeleteBookmarkMutationOptions = Apollo.BaseMutationOptions<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>
export const AddBookmarkDocument = gql`
  mutation addBookmark($data: AddBookmarkInput!) {
    addBookmark(data: $data) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`
export type AddBookmarkMutationFn = Apollo.MutationFunction<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>

/**
 * __useAddBookmarkMutation__
 *
 * To run a mutation, you first call `useAddBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkMutation, { data, loading, error }] = useAddBookmarkMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddBookmarkMutation,
    AddBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddBookmarkMutation, AddBookmarkMutationVariables>(
    AddBookmarkDocument,
    options
  )
}
export type AddBookmarkMutationHookResult = ReturnType<
  typeof useAddBookmarkMutation
>
export type AddBookmarkMutationResult =
  Apollo.MutationResult<AddBookmarkMutation>
export type AddBookmarkMutationOptions = Apollo.BaseMutationOptions<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>
export const AddCommentDocument = gql`
  mutation addComment($refId: ID!, $type: CommentType!, $text: String!) {
    addComment(refId: $refId, type: $type, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type AddCommentMutationFn = Apollo.MutationFunction<
  AddCommentMutation,
  AddCommentMutationVariables
>

/**
 * __useAddCommentMutation__
 *
 * To run a mutation, you first call `useAddCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCommentMutation, { data, loading, error }] = useAddCommentMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useAddCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddCommentMutation,
    AddCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddCommentMutation, AddCommentMutationVariables>(
    AddCommentDocument,
    options
  )
}
export type AddCommentMutationHookResult = ReturnType<
  typeof useAddCommentMutation
>
export type AddCommentMutationResult = Apollo.MutationResult<AddCommentMutation>
export type AddCommentMutationOptions = Apollo.BaseMutationOptions<
  AddCommentMutation,
  AddCommentMutationVariables
>
export const EditCommentDocument = gql`
  mutation editComment($id: ID!, $text: String!) {
    editComment(id: $id, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type EditCommentMutationFn = Apollo.MutationFunction<
  EditCommentMutation,
  EditCommentMutationVariables
>

/**
 * __useEditCommentMutation__
 *
 * To run a mutation, you first call `useEditCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCommentMutation, { data, loading, error }] = useEditCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useEditCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditCommentMutation,
    EditCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditCommentMutation, EditCommentMutationVariables>(
    EditCommentDocument,
    options
  )
}
export type EditCommentMutationHookResult = ReturnType<
  typeof useEditCommentMutation
>
export type EditCommentMutationResult =
  Apollo.MutationResult<EditCommentMutation>
export type EditCommentMutationOptions = Apollo.BaseMutationOptions<
  EditCommentMutation,
  EditCommentMutationVariables
>
export const DeleteCommentDocument = gql`
  mutation deleteComment($id: ID!) {
    deleteComment(id: $id)
  }
`
export type DeleteCommentMutationFn = Apollo.MutationFunction<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >(DeleteCommentDocument, options)
}
export type DeleteCommentMutationHookResult = ReturnType<
  typeof useDeleteCommentMutation
>
export type DeleteCommentMutationResult =
  Apollo.MutationResult<DeleteCommentMutation>
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>
export const EditEmailSubscriptionDocument = gql`
  mutation editEmailSubscription($data: EmailSubscriptionInput) {
    editEmailSubscription(data: $data) {
      emailSubscriptions {
        subscribed
        type
      }
    }
  }
`
export type EditEmailSubscriptionMutationFn = Apollo.MutationFunction<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>

/**
 * __useEditEmailSubscriptionMutation__
 *
 * To run a mutation, you first call `useEditEmailSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditEmailSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editEmailSubscriptionMutation, { data, loading, error }] = useEditEmailSubscriptionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditEmailSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >(EditEmailSubscriptionDocument, options)
}
export type EditEmailSubscriptionMutationHookResult = ReturnType<
  typeof useEditEmailSubscriptionMutation
>
export type EditEmailSubscriptionMutationResult =
  Apollo.MutationResult<EditEmailSubscriptionMutation>
export type EditEmailSubscriptionMutationOptions = Apollo.BaseMutationOptions<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>
export const EditPageDocument = gql`
  mutation editPage($id: ID!, $data: EditPageInput!) {
    editPage(id: $id, data: $data) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`
export type EditPageMutationFn = Apollo.MutationFunction<
  EditPageMutation,
  EditPageMutationVariables
>

/**
 * __useEditPageMutation__
 *
 * To run a mutation, you first call `useEditPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPageMutation, { data, loading, error }] = useEditPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditPageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditPageMutation,
    EditPageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditPageMutation, EditPageMutationVariables>(
    EditPageDocument,
    options
  )
}
export type EditPageMutationHookResult = ReturnType<typeof useEditPageMutation>
export type EditPageMutationResult = Apollo.MutationResult<EditPageMutation>
export type EditPageMutationOptions = Apollo.BaseMutationOptions<
  EditPageMutation,
  EditPageMutationVariables
>
export const DeletePageDocument = gql`
  mutation deletePage($id: ID!) {
    deletePage(id: $id)
  }
`
export type DeletePageMutationFn = Apollo.MutationFunction<
  DeletePageMutation,
  DeletePageMutationVariables
>

/**
 * __useDeletePageMutation__
 *
 * To run a mutation, you first call `useDeletePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePageMutation, { data, loading, error }] = useDeletePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePageMutation,
    DeletePageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePageMutation, DeletePageMutationVariables>(
    DeletePageDocument,
    options
  )
}
export type DeletePageMutationHookResult = ReturnType<
  typeof useDeletePageMutation
>
export type DeletePageMutationResult = Apollo.MutationResult<DeletePageMutation>
export type DeletePageMutationOptions = Apollo.BaseMutationOptions<
  DeletePageMutation,
  DeletePageMutationVariables
>
export const AddPageDocument = gql`
  mutation addPage($data: AddPageInput!) {
    addPage(data: $data) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`
export type AddPageMutationFn = Apollo.MutationFunction<
  AddPageMutation,
  AddPageMutationVariables
>

/**
 * __useAddPageMutation__
 *
 * To run a mutation, you first call `useAddPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPageMutation, { data, loading, error }] = useAddPageMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddPageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddPageMutation,
    AddPageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddPageMutation, AddPageMutationVariables>(
    AddPageDocument,
    options
  )
}
export type AddPageMutationHookResult = ReturnType<typeof useAddPageMutation>
export type AddPageMutationResult = Apollo.MutationResult<AddPageMutation>
export type AddPageMutationOptions = Apollo.BaseMutationOptions<
  AddPageMutation,
  AddPageMutationVariables
>
export const EditPostDocument = gql`
  mutation editPost($id: ID!, $data: EditPostInput!) {
    editPost(id: $id, data: $data) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`
export type EditPostMutationFn = Apollo.MutationFunction<
  EditPostMutation,
  EditPostMutationVariables
>

/**
 * __useEditPostMutation__
 *
 * To run a mutation, you first call `useEditPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPostMutation, { data, loading, error }] = useEditPostMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditPostMutation,
    EditPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditPostMutation, EditPostMutationVariables>(
    EditPostDocument,
    options
  )
}
export type EditPostMutationHookResult = ReturnType<typeof useEditPostMutation>
export type EditPostMutationResult = Apollo.MutationResult<EditPostMutation>
export type EditPostMutationOptions = Apollo.BaseMutationOptions<
  EditPostMutation,
  EditPostMutationVariables
>
export const DeletePostDocument = gql`
  mutation deletePost($id: ID!) {
    deletePost(id: $id)
  }
`
export type DeletePostMutationFn = Apollo.MutationFunction<
  DeletePostMutation,
  DeletePostMutationVariables
>

/**
 * __useDeletePostMutation__
 *
 * To run a mutation, you first call `useDeletePostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePostMutation, { data, loading, error }] = useDeletePostMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePostMutation,
    DeletePostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePostMutation, DeletePostMutationVariables>(
    DeletePostDocument,
    options
  )
}
export type DeletePostMutationHookResult = ReturnType<
  typeof useDeletePostMutation
>
export type DeletePostMutationResult = Apollo.MutationResult<DeletePostMutation>
export type DeletePostMutationOptions = Apollo.BaseMutationOptions<
  DeletePostMutation,
  DeletePostMutationVariables
>
export const AddPostDocument = gql`
  mutation addPost($data: AddPostInput!) {
    addPost(data: $data) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`
export type AddPostMutationFn = Apollo.MutationFunction<
  AddPostMutation,
  AddPostMutationVariables
>

/**
 * __useAddPostMutation__
 *
 * To run a mutation, you first call `useAddPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPostMutation, { data, loading, error }] = useAddPostMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddPostMutation,
    AddPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddPostMutation, AddPostMutationVariables>(
    AddPostDocument,
    options
  )
}
export type AddPostMutationHookResult = ReturnType<typeof useAddPostMutation>
export type AddPostMutationResult = Apollo.MutationResult<AddPostMutation>
export type AddPostMutationOptions = Apollo.BaseMutationOptions<
  AddPostMutation,
  AddPostMutationVariables
>
export const EditQuestionDocument = gql`
  mutation editQuestion($id: ID!, $data: EditQuestionInput!) {
    editQuestion(id: $id, data: $data) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`
export type EditQuestionMutationFn = Apollo.MutationFunction<
  EditQuestionMutation,
  EditQuestionMutationVariables
>

/**
 * __useEditQuestionMutation__
 *
 * To run a mutation, you first call `useEditQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editQuestionMutation, { data, loading, error }] = useEditQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >(EditQuestionDocument, options)
}
export type EditQuestionMutationHookResult = ReturnType<
  typeof useEditQuestionMutation
>
export type EditQuestionMutationResult =
  Apollo.MutationResult<EditQuestionMutation>
export type EditQuestionMutationOptions = Apollo.BaseMutationOptions<
  EditQuestionMutation,
  EditQuestionMutationVariables
>
export const DeleteQuestionDocument = gql`
  mutation deleteQuestion($id: ID!) {
    deleteQuestion(id: $id)
  }
`
export type DeleteQuestionMutationFn = Apollo.MutationFunction<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>

/**
 * __useDeleteQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteQuestionMutation, { data, loading, error }] = useDeleteQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >(DeleteQuestionDocument, options)
}
export type DeleteQuestionMutationHookResult = ReturnType<
  typeof useDeleteQuestionMutation
>
export type DeleteQuestionMutationResult =
  Apollo.MutationResult<DeleteQuestionMutation>
export type DeleteQuestionMutationOptions = Apollo.BaseMutationOptions<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>
export const AddQuestionDocument = gql`
  mutation addQuestion($data: AddQuestionInput!) {
    addQuestion(data: $data) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`
export type AddQuestionMutationFn = Apollo.MutationFunction<
  AddQuestionMutation,
  AddQuestionMutationVariables
>

/**
 * __useAddQuestionMutation__
 *
 * To run a mutation, you first call `useAddQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addQuestionMutation, { data, loading, error }] = useAddQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddQuestionMutation,
    AddQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddQuestionMutation, AddQuestionMutationVariables>(
    AddQuestionDocument,
    options
  )
}
export type AddQuestionMutationHookResult = ReturnType<
  typeof useAddQuestionMutation
>
export type AddQuestionMutationResult =
  Apollo.MutationResult<AddQuestionMutation>
export type AddQuestionMutationOptions = Apollo.BaseMutationOptions<
  AddQuestionMutation,
  AddQuestionMutationVariables
>
export const ToggleReactionDocument = gql`
  mutation toggleReaction($refId: ID!, $type: ReactionType!) {
    toggleReaction(refId: $refId, type: $type) {
      ... on Bookmark {
        id
        url
        reactionCount
        viewerHasReacted
      }
      ... on Question {
        id
        reactionCount
        viewerHasReacted
      }
      ... on Post {
        id
        reactionCount
        viewerHasReacted
      }
    }
  }
`
export type ToggleReactionMutationFn = Apollo.MutationFunction<
  ToggleReactionMutation,
  ToggleReactionMutationVariables
>

/**
 * __useToggleReactionMutation__
 *
 * To run a mutation, you first call `useToggleReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useToggleReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [toggleReactionMutation, { data, loading, error }] = useToggleReactionMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useToggleReactionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ToggleReactionMutation,
    ToggleReactionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    ToggleReactionMutation,
    ToggleReactionMutationVariables
  >(ToggleReactionDocument, options)
}
export type ToggleReactionMutationHookResult = ReturnType<
  typeof useToggleReactionMutation
>
export type ToggleReactionMutationResult =
  Apollo.MutationResult<ToggleReactionMutation>
export type ToggleReactionMutationOptions = Apollo.BaseMutationOptions<
  ToggleReactionMutation,
  ToggleReactionMutationVariables
>
export const EditSiteDomainDocument = gql`
  mutation editSiteDomain($subdomain: String!, $data: EditSiteDomainInput!) {
    editSiteDomain(subdomain: $subdomain, data: $data) {
      ...SiteInfo
    }
  }
  ${SiteInfoFragmentDoc}
`
export type EditSiteDomainMutationFn = Apollo.MutationFunction<
  EditSiteDomainMutation,
  EditSiteDomainMutationVariables
>

/**
 * __useEditSiteDomainMutation__
 *
 * To run a mutation, you first call `useEditSiteDomainMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSiteDomainMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSiteDomainMutation, { data, loading, error }] = useEditSiteDomainMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditSiteDomainMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSiteDomainMutation,
    EditSiteDomainMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditSiteDomainMutation,
    EditSiteDomainMutationVariables
  >(EditSiteDomainDocument, options)
}
export type EditSiteDomainMutationHookResult = ReturnType<
  typeof useEditSiteDomainMutation
>
export type EditSiteDomainMutationResult =
  Apollo.MutationResult<EditSiteDomainMutation>
export type EditSiteDomainMutationOptions = Apollo.BaseMutationOptions<
  EditSiteDomainMutation,
  EditSiteDomainMutationVariables
>
export const EditSiteDocument = gql`
  mutation editSite($subdomain: String!, $data: EditSiteInput!) {
    editSite(subdomain: $subdomain, data: $data) {
      ...SiteInfo
    }
  }
  ${SiteInfoFragmentDoc}
`
export type EditSiteMutationFn = Apollo.MutationFunction<
  EditSiteMutation,
  EditSiteMutationVariables
>

/**
 * __useEditSiteMutation__
 *
 * To run a mutation, you first call `useEditSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSiteMutation, { data, loading, error }] = useEditSiteMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSiteMutation,
    EditSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditSiteMutation, EditSiteMutationVariables>(
    EditSiteDocument,
    options
  )
}
export type EditSiteMutationHookResult = ReturnType<typeof useEditSiteMutation>
export type EditSiteMutationResult = Apollo.MutationResult<EditSiteMutation>
export type EditSiteMutationOptions = Apollo.BaseMutationOptions<
  EditSiteMutation,
  EditSiteMutationVariables
>
export const DeleteSiteDocument = gql`
  mutation deleteSite($subdomain: String!) {
    deleteSite(subdomain: $subdomain)
  }
`
export type DeleteSiteMutationFn = Apollo.MutationFunction<
  DeleteSiteMutation,
  DeleteSiteMutationVariables
>

/**
 * __useDeleteSiteMutation__
 *
 * To run a mutation, you first call `useDeleteSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSiteMutation, { data, loading, error }] = useDeleteSiteMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *   },
 * });
 */
export function useDeleteSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteSiteMutation,
    DeleteSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteSiteMutation, DeleteSiteMutationVariables>(
    DeleteSiteDocument,
    options
  )
}
export type DeleteSiteMutationHookResult = ReturnType<
  typeof useDeleteSiteMutation
>
export type DeleteSiteMutationResult = Apollo.MutationResult<DeleteSiteMutation>
export type DeleteSiteMutationOptions = Apollo.BaseMutationOptions<
  DeleteSiteMutation,
  DeleteSiteMutationVariables
>
export const AddSiteDocument = gql`
  mutation addSite($data: AddSiteInput!) {
    addSite(data: $data) {
      ...SiteInfo
    }
  }
  ${SiteInfoFragmentDoc}
`
export type AddSiteMutationFn = Apollo.MutationFunction<
  AddSiteMutation,
  AddSiteMutationVariables
>

/**
 * __useAddSiteMutation__
 *
 * To run a mutation, you first call `useAddSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addSiteMutation, { data, loading, error }] = useAddSiteMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddSiteMutation,
    AddSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddSiteMutation, AddSiteMutationVariables>(
    AddSiteDocument,
    options
  )
}
export type AddSiteMutationHookResult = ReturnType<typeof useAddSiteMutation>
export type AddSiteMutationResult = Apollo.MutationResult<AddSiteMutation>
export type AddSiteMutationOptions = Apollo.BaseMutationOptions<
  AddSiteMutation,
  AddSiteMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser {
    deleteUser
  }
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const EditUserDocument = gql`
  mutation editUser($data: EditUserInput) {
    editUser(data: $data) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export type EditUserMutationFn = Apollo.MutationFunction<
  EditUserMutation,
  EditUserMutationVariables
>

/**
 * __useEditUserMutation__
 *
 * To run a mutation, you first call `useEditUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editUserMutation, { data, loading, error }] = useEditUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditUserMutation,
    EditUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditUserMutation, EditUserMutationVariables>(
    EditUserDocument,
    options
  )
}
export type EditUserMutationHookResult = ReturnType<typeof useEditUserMutation>
export type EditUserMutationResult = Apollo.MutationResult<EditUserMutation>
export type EditUserMutationOptions = Apollo.BaseMutationOptions<
  EditUserMutation,
  EditUserMutationVariables
>
export const GetBookmarksDocument = gql`
  query getBookmarks($first: Int, $after: String, $filter: BookmarkFilter) {
    bookmarks(first: $first, after: $after, filter: $filter) {
      ...BookmarksConnection
    }
  }
  ${BookmarksConnectionFragmentDoc}
`

/**
 * __useGetBookmarksQuery__
 *
 * To run a query within a React component, call `useGetBookmarksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetBookmarksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export function useGetBookmarksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export type GetBookmarksQueryHookResult = ReturnType<
  typeof useGetBookmarksQuery
>
export type GetBookmarksLazyQueryHookResult = ReturnType<
  typeof useGetBookmarksLazyQuery
>
export type GetBookmarksQueryResult = Apollo.QueryResult<
  GetBookmarksQuery,
  GetBookmarksQueryVariables
>
export const GetBookmarkDocument = gql`
  query getBookmark($id: ID!) {
    bookmark(id: $id) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`

/**
 * __useGetBookmarkQuery__
 *
 * To run a query within a React component, call `useGetBookmarkQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarkQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBookmarkQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export function useGetBookmarkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export type GetBookmarkQueryHookResult = ReturnType<typeof useGetBookmarkQuery>
export type GetBookmarkLazyQueryHookResult = ReturnType<
  typeof useGetBookmarkLazyQuery
>
export type GetBookmarkQueryResult = Apollo.QueryResult<
  GetBookmarkQuery,
  GetBookmarkQueryVariables
>
export const GetCommentsDocument = gql`
  query getComments($refId: ID!, $type: CommentType!) {
    comments(refId: $refId, type: $type) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`

/**
 * __useGetCommentsQuery__
 *
 * To run a query within a React component, call `useGetCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCommentsQuery({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCommentsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export type GetCommentsQueryHookResult = ReturnType<typeof useGetCommentsQuery>
export type GetCommentsLazyQueryHookResult = ReturnType<
  typeof useGetCommentsLazyQuery
>
export type GetCommentsQueryResult = Apollo.QueryResult<
  GetCommentsQuery,
  GetCommentsQueryVariables
>
export const GetEmailSubscriptionsDocument = gql`
  query getEmailSubscriptions($first: Int, $after: String) {
    emailSubscriptions(first: $first, after: $after) {
      ...EmailSubscriptionsConnection
    }
  }
  ${EmailSubscriptionsConnectionFragmentDoc}
`

/**
 * __useGetEmailSubscriptionsQuery__
 *
 * To run a query within a React component, call `useGetEmailSubscriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEmailSubscriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEmailSubscriptionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetEmailSubscriptionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >(GetEmailSubscriptionsDocument, options)
}
export function useGetEmailSubscriptionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >(GetEmailSubscriptionsDocument, options)
}
export type GetEmailSubscriptionsQueryHookResult = ReturnType<
  typeof useGetEmailSubscriptionsQuery
>
export type GetEmailSubscriptionsLazyQueryHookResult = ReturnType<
  typeof useGetEmailSubscriptionsLazyQuery
>
export type GetEmailSubscriptionsQueryResult = Apollo.QueryResult<
  GetEmailSubscriptionsQuery,
  GetEmailSubscriptionsQueryVariables
>
export const GetPagesDocument = gql`
  query getPages($filter: PagesFilter) {
    pages(filter: $filter) {
      ...PageListItem
    }
  }
  ${PageListItemFragmentDoc}
`

/**
 * __useGetPagesQuery__
 *
 * To run a query within a React component, call `useGetPagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPagesQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetPagesQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPagesQuery, GetPagesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPagesQuery, GetPagesQueryVariables>(
    GetPagesDocument,
    options
  )
}
export function useGetPagesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPagesQuery,
    GetPagesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPagesQuery, GetPagesQueryVariables>(
    GetPagesDocument,
    options
  )
}
export type GetPagesQueryHookResult = ReturnType<typeof useGetPagesQuery>
export type GetPagesLazyQueryHookResult = ReturnType<
  typeof useGetPagesLazyQuery
>
export type GetPagesQueryResult = Apollo.QueryResult<
  GetPagesQuery,
  GetPagesQueryVariables
>
export const GetPageDocument = gql`
  query getPage($slug: String!) {
    page(slug: $slug) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`

/**
 * __useGetPageQuery__
 *
 * To run a query within a React component, call `useGetPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPageQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPageQuery(
  baseOptions: Apollo.QueryHookOptions<GetPageQuery, GetPageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPageQuery, GetPageQueryVariables>(
    GetPageDocument,
    options
  )
}
export function useGetPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPageQuery, GetPageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPageQuery, GetPageQueryVariables>(
    GetPageDocument,
    options
  )
}
export type GetPageQueryHookResult = ReturnType<typeof useGetPageQuery>
export type GetPageLazyQueryHookResult = ReturnType<typeof useGetPageLazyQuery>
export type GetPageQueryResult = Apollo.QueryResult<
  GetPageQuery,
  GetPageQueryVariables
>
export const GetHomePageDocument = gql`
  query getHomePage {
    homepage {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`

/**
 * __useGetHomePageQuery__
 *
 * To run a query within a React component, call `useGetHomePageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHomePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHomePageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetHomePageQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetHomePageQuery,
    GetHomePageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetHomePageQuery, GetHomePageQueryVariables>(
    GetHomePageDocument,
    options
  )
}
export function useGetHomePageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetHomePageQuery,
    GetHomePageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetHomePageQuery, GetHomePageQueryVariables>(
    GetHomePageDocument,
    options
  )
}
export type GetHomePageQueryHookResult = ReturnType<typeof useGetHomePageQuery>
export type GetHomePageLazyQueryHookResult = ReturnType<
  typeof useGetHomePageLazyQuery
>
export type GetHomePageQueryResult = Apollo.QueryResult<
  GetHomePageQuery,
  GetHomePageQueryVariables
>
export const GetPostsDocument = gql`
  query getPosts($filter: WritingFilter) {
    posts(filter: $filter) {
      ...PostListItem
    }
  }
  ${PostListItemFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetPostDocument = gql`
  query getPost($slug: String!) {
    post(slug: $slug) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetQuestionsDocument = gql`
  query getQuestions($first: Int, $after: String, $filter: QuestionFilter) {
    questions(first: $first, after: $after, filter: $filter) {
      ...QuestionsConnection
    }
  }
  ${QuestionsConnectionFragmentDoc}
`

/**
 * __useGetQuestionsQuery__
 *
 * To run a query within a React component, call `useGetQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export function useGetQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export type GetQuestionsQueryHookResult = ReturnType<
  typeof useGetQuestionsQuery
>
export type GetQuestionsLazyQueryHookResult = ReturnType<
  typeof useGetQuestionsLazyQuery
>
export type GetQuestionsQueryResult = Apollo.QueryResult<
  GetQuestionsQuery,
  GetQuestionsQueryVariables
>
export const GetQuestionDocument = gql`
  query getQuestion($id: ID!) {
    question(id: $id) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`

/**
 * __useGetQuestionQuery__
 *
 * To run a query within a React component, call `useGetQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetQuestionQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export function useGetQuestionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export type GetQuestionQueryHookResult = ReturnType<typeof useGetQuestionQuery>
export type GetQuestionLazyQueryHookResult = ReturnType<
  typeof useGetQuestionLazyQuery
>
export type GetQuestionQueryResult = Apollo.QueryResult<
  GetQuestionQuery,
  GetQuestionQueryVariables
>
export const GetSitesDocument = gql`
  query getSites {
    userSites {
      ...UserSiteInfo
    }
  }
  ${UserSiteInfoFragmentDoc}
`

/**
 * __useGetSitesQuery__
 *
 * To run a query within a React component, call `useGetSitesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSitesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSitesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSitesQuery(
  baseOptions?: Apollo.QueryHookOptions<GetSitesQuery, GetSitesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSitesQuery, GetSitesQueryVariables>(
    GetSitesDocument,
    options
  )
}
export function useGetSitesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSitesQuery,
    GetSitesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSitesQuery, GetSitesQueryVariables>(
    GetSitesDocument,
    options
  )
}
export type GetSitesQueryHookResult = ReturnType<typeof useGetSitesQuery>
export type GetSitesLazyQueryHookResult = ReturnType<
  typeof useGetSitesLazyQuery
>
export type GetSitesQueryResult = Apollo.QueryResult<
  GetSitesQuery,
  GetSitesQueryVariables
>
export const GetTagsDocument = gql`
  query getTags {
    tags {
      name
    }
  }
`

/**
 * __useGetTagsQuery__
 *
 * To run a query within a React component, call `useGetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTagsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTagsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export function useGetTagsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export type GetTagsQueryHookResult = ReturnType<typeof useGetTagsQuery>
export type GetTagsLazyQueryHookResult = ReturnType<typeof useGetTagsLazyQuery>
export type GetTagsQueryResult = Apollo.QueryResult<
  GetTagsQuery,
  GetTagsQueryVariables
>
export const GetUserDocument = gql`
  query getUser($username: String!) {
    user(username: $username) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
export const GetViewerWithSettingsDocument = gql`
  query getViewerWithSettings {
    context {
      viewer {
        ...UserInfo
        ...UserSettings
      }
    }
  }
  ${UserInfoFragmentDoc}
  ${UserSettingsFragmentDoc}
`

/**
 * __useGetViewerWithSettingsQuery__
 *
 * To run a query within a React component, call `useGetViewerWithSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetViewerWithSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetViewerWithSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetViewerWithSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export function useGetViewerWithSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export type GetViewerWithSettingsQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsQuery
>
export type GetViewerWithSettingsLazyQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsLazyQuery
>
export type GetViewerWithSettingsQueryResult = Apollo.QueryResult<
  GetViewerWithSettingsQuery,
  GetViewerWithSettingsQueryVariables
>
export const ContextDocument = gql`
  query context {
    context {
      viewer {
        ...UserInfo
      }
      site {
        ...SiteInfo
      }
      userSite {
        ...UserSite
      }
      owner {
        image
        avatar
      }
    }
  }
  ${UserInfoFragmentDoc}
  ${SiteInfoFragmentDoc}
  ${UserSiteFragmentDoc}
`

/**
 * __useContextQuery__
 *
 * To run a query within a React component, call `useContextQuery` and pass it any options that fit your needs.
 * When your component renders, `useContextQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContextQuery({
 *   variables: {
 *   },
 * });
 */
export function useContextQuery(
  baseOptions?: Apollo.QueryHookOptions<ContextQuery, ContextQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ContextQuery, ContextQueryVariables>(
    ContextDocument,
    options
  )
}
export function useContextLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ContextQuery, ContextQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ContextQuery, ContextQueryVariables>(
    ContextDocument,
    options
  )
}
export type ContextQueryHookResult = ReturnType<typeof useContextQuery>
export type ContextLazyQueryHookResult = ReturnType<typeof useContextLazyQuery>
export type ContextQueryResult = Apollo.QueryResult<
  ContextQuery,
  ContextQueryVariables
>
