// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never }
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never
    }
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string }
  String: { input: string; output: string }
  Boolean: { input: boolean; output: boolean }
  Int: { input: number; output: number }
  Float: { input: number; output: number }
  Date: { input: any; output: any }
}

export type AddBookmarkInput = {
  content?: InputMaybe<Scalars['String']['input']>
  tag?: InputMaybe<Scalars['String']['input']>
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  url: Scalars['String']['input']
}

export type AddPageInput = {
  access?: InputMaybe<PageAccess>
  data: Scalars['String']['input']
  excerpt?: InputMaybe<Scalars['String']['input']>
  featured?: InputMaybe<Scalars['Boolean']['input']>
  path: Scalars['String']['input']
  slug: Scalars['String']['input']
  text: Scalars['String']['input']
  title: Scalars['String']['input']
}

export type AddPostInput = {
  access?: InputMaybe<PostAccess>
  data: Scalars['String']['input']
  excerpt?: InputMaybe<Scalars['String']['input']>
  published?: InputMaybe<Scalars['Boolean']['input']>
  slug: Scalars['String']['input']
  text: Scalars['String']['input']
  title: Scalars['String']['input']
}

export type AddQuestionInput = {
  description?: InputMaybe<Scalars['String']['input']>
  title: Scalars['String']['input']
}

export type AddSiteInput = {
  subdomain: Scalars['String']['input']
}

export type Bookmark = {
  __typename?: 'Bookmark'
  content?: Maybe<Scalars['String']['output']>
  createdAt: Scalars['Date']['output']
  description?: Maybe<Scalars['String']['output']>
  faviconUrl?: Maybe<Scalars['String']['output']>
  host: Scalars['String']['output']
  html?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  image?: Maybe<Scalars['String']['output']>
  reactionCount?: Maybe<Scalars['Int']['output']>
  tags: Array<Maybe<Tag>>
  title?: Maybe<Scalars['String']['output']>
  updatedAt: Scalars['Date']['output']
  url: Scalars['String']['output']
  viewerHasReacted?: Maybe<Scalars['Boolean']['output']>
}

export type BookmarkEdge = {
  __typename?: 'BookmarkEdge'
  cursor?: Maybe<Scalars['String']['output']>
  node?: Maybe<Bookmark>
}

export type BookmarkFilter = {
  host?: InputMaybe<Scalars['String']['input']>
  tag?: InputMaybe<Scalars['String']['input']>
}

export type BookmarksConnection = {
  __typename?: 'BookmarksConnection'
  edges: Array<Maybe<BookmarkEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Comment = {
  __typename?: 'Comment'
  author: User
  createdAt: Scalars['Date']['output']
  id: Scalars['ID']['output']
  text?: Maybe<Scalars['String']['output']>
  updatedAt?: Maybe<Scalars['Date']['output']>
  viewerCanDelete?: Maybe<Scalars['Boolean']['output']>
  viewerCanEdit?: Maybe<Scalars['Boolean']['output']>
}

export enum CommentType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
}

export type EditBookmarkInput = {
  description?: InputMaybe<Scalars['String']['input']>
  faviconUrl?: InputMaybe<Scalars['String']['input']>
  tag?: InputMaybe<Scalars['String']['input']>
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  title: Scalars['String']['input']
}

export type EditPageInput = {
  access?: InputMaybe<PageAccess>
  data: Scalars['String']['input']
  excerpt?: InputMaybe<Scalars['String']['input']>
  featured?: InputMaybe<Scalars['Boolean']['input']>
  path: Scalars['String']['input']
  published?: InputMaybe<Scalars['Boolean']['input']>
  publishedAt?: InputMaybe<Scalars['Date']['input']>
  slug: Scalars['String']['input']
  text: Scalars['String']['input']
  title: Scalars['String']['input']
}

export type EditPostInput = {
  access?: InputMaybe<PostAccess>
  data: Scalars['String']['input']
  excerpt?: InputMaybe<Scalars['String']['input']>
  publishNewsletter?: InputMaybe<Scalars['Boolean']['input']>
  published?: InputMaybe<Scalars['Boolean']['input']>
  publishedAt?: InputMaybe<Scalars['Date']['input']>
  slug: Scalars['String']['input']
  text: Scalars['String']['input']
  title: Scalars['String']['input']
}

export type EditQuestionInput = {
  description?: InputMaybe<Scalars['String']['input']>
  title: Scalars['String']['input']
}

export type EditSiteChatBotInput = {
  openai_key?: InputMaybe<Scalars['String']['input']>
  prompt_template?: InputMaybe<Scalars['String']['input']>
}

export type EditSiteDomainInput = {
  parkedDomain: Scalars['String']['input']
}

export type EditSiteInput = {
  attach_css?: InputMaybe<Scalars['String']['input']>
  attach_js?: InputMaybe<Scalars['String']['input']>
  banner?: InputMaybe<Scalars['String']['input']>
  description?: InputMaybe<Scalars['String']['input']>
  logo?: InputMaybe<Scalars['String']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  newsletter_description?: InputMaybe<Scalars['String']['input']>
  newsletter_double_optin?: InputMaybe<Scalars['Boolean']['input']>
  newsletter_from_email?: InputMaybe<Scalars['String']['input']>
  newsletter_provider?: InputMaybe<Scalars['String']['input']>
  newsletter_setting1?: InputMaybe<Scalars['String']['input']>
  newsletter_setting2?: InputMaybe<Scalars['String']['input']>
  newsletter_setting3?: InputMaybe<Scalars['String']['input']>
  social_github?: InputMaybe<Scalars['String']['input']>
  social_other1?: InputMaybe<Scalars['String']['input']>
  social_other1_label?: InputMaybe<Scalars['String']['input']>
  social_twitter?: InputMaybe<Scalars['String']['input']>
  social_youtube?: InputMaybe<Scalars['String']['input']>
}

export type EditSiteUserInput = {
  siteRole?: InputMaybe<SiteRole>
  userId?: InputMaybe<Scalars['String']['input']>
}

export type EditUserInput = {
  email?: InputMaybe<Scalars['String']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  username?: InputMaybe<Scalars['String']['input']>
}

export type EmailSubscription = {
  __typename?: 'EmailSubscription'
  email?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  type?: Maybe<EmailSubscriptionType>
  userId?: Maybe<Scalars['String']['output']>
}

export type EmailSubscriptionEdge = {
  __typename?: 'EmailSubscriptionEdge'
  cursor?: Maybe<Scalars['String']['output']>
  node?: Maybe<EmailSubscription>
}

export type EmailSubscriptionInput = {
  email?: InputMaybe<Scalars['String']['input']>
  subscribed: Scalars['Boolean']['input']
  type: EmailSubscriptionType
}

export enum EmailSubscriptionType {
  Newsletter = 'NEWSLETTER',
}

export type EmailSubscriptionsConnection = {
  __typename?: 'EmailSubscriptionsConnection'
  edges: Array<Maybe<EmailSubscriptionEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Mutation = {
  __typename?: 'Mutation'
  addBookmark?: Maybe<Bookmark>
  addComment?: Maybe<Comment>
  addPage?: Maybe<Page>
  addPost?: Maybe<Post>
  addQuestion?: Maybe<Question>
  addSite?: Maybe<Site>
  deleteBookmark?: Maybe<Scalars['Boolean']['output']>
  deleteComment?: Maybe<Scalars['Boolean']['output']>
  deletePage?: Maybe<Scalars['Boolean']['output']>
  deletePost?: Maybe<Scalars['Boolean']['output']>
  deleteQuestion?: Maybe<Scalars['Boolean']['output']>
  deleteSite?: Maybe<Scalars['Boolean']['output']>
  deleteUser?: Maybe<Scalars['Boolean']['output']>
  editBookmark?: Maybe<Bookmark>
  editComment?: Maybe<Comment>
  editEmailSubscription?: Maybe<User>
  editPage?: Maybe<Page>
  editPost?: Maybe<Post>
  editQuestion?: Maybe<Question>
  editSite?: Maybe<Site>
  editSiteDomain?: Maybe<Site>
  editSiteUser?: Maybe<SiteUser>
  editUser?: Maybe<User>
  setUserApiKey?: Maybe<User>
  toggleReaction?: Maybe<Reactable>
}

export type MutationAddBookmarkArgs = {
  data: AddBookmarkInput
}

export type MutationAddCommentArgs = {
  refId: Scalars['ID']['input']
  text: Scalars['String']['input']
  type: CommentType
}

export type MutationAddPageArgs = {
  data: AddPageInput
}

export type MutationAddPostArgs = {
  data: AddPostInput
}

export type MutationAddQuestionArgs = {
  data: AddQuestionInput
}

export type MutationAddSiteArgs = {
  data: AddSiteInput
}

export type MutationDeleteBookmarkArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeletePageArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeletePostArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeleteQuestionArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeleteSiteArgs = {
  subdomain: Scalars['String']['input']
}

export type MutationEditBookmarkArgs = {
  data: EditBookmarkInput
  id: Scalars['ID']['input']
}

export type MutationEditCommentArgs = {
  id: Scalars['ID']['input']
  text?: InputMaybe<Scalars['String']['input']>
}

export type MutationEditEmailSubscriptionArgs = {
  data?: InputMaybe<EmailSubscriptionInput>
}

export type MutationEditPageArgs = {
  data: EditPageInput
  id: Scalars['ID']['input']
}

export type MutationEditPostArgs = {
  data: EditPostInput
  id: Scalars['ID']['input']
}

export type MutationEditQuestionArgs = {
  data: EditQuestionInput
  id: Scalars['ID']['input']
}

export type MutationEditSiteArgs = {
  chatbot?: InputMaybe<EditSiteChatBotInput>
  data: EditSiteInput
  subdomain: Scalars['String']['input']
}

export type MutationEditSiteDomainArgs = {
  data: EditSiteDomainInput
  subdomain: Scalars['String']['input']
}

export type MutationEditSiteUserArgs = {
  data: EditSiteUserInput
}

export type MutationEditUserArgs = {
  data?: InputMaybe<EditUserInput>
}

export type MutationSetUserApiKeyArgs = {
  data?: InputMaybe<SetUserApiKeyInput>
}

export type MutationToggleReactionArgs = {
  refId: Scalars['ID']['input']
  type: ReactionType
}

export type Page = {
  __typename?: 'Page'
  _isMasked?: Maybe<Scalars['Boolean']['output']>
  access?: Maybe<PageAccess>
  author?: Maybe<User>
  createdAt?: Maybe<Scalars['Date']['output']>
  data?: Maybe<Scalars['String']['output']>
  excerpt?: Maybe<Scalars['String']['output']>
  featureImage?: Maybe<Scalars['String']['output']>
  featured?: Maybe<Scalars['Boolean']['output']>
  id: Scalars['ID']['output']
  path?: Maybe<Scalars['String']['output']>
  publishedAt?: Maybe<Scalars['Date']['output']>
  slug?: Maybe<Scalars['String']['output']>
  text?: Maybe<Scalars['String']['output']>
  title?: Maybe<Scalars['String']['output']>
  updatedAt?: Maybe<Scalars['Date']['output']>
}

export enum PageAccess {
  Members = 'MEMBERS',
  PaidMembers = 'PAID_MEMBERS',
  Public = 'PUBLIC',
}

export type PageInfo = {
  __typename?: 'PageInfo'
  endCursor?: Maybe<Scalars['String']['output']>
  hasNextPage?: Maybe<Scalars['Boolean']['output']>
  totalCount?: Maybe<Scalars['Int']['output']>
}

export type PagesFilter = {
  featuredOnly?: InputMaybe<Scalars['Boolean']['input']>
  includeHomepage?: InputMaybe<Scalars['Boolean']['input']>
  published?: InputMaybe<Scalars['Boolean']['input']>
}

export type Post = {
  __typename?: 'Post'
  _isMasked?: Maybe<Scalars['Boolean']['output']>
  access?: Maybe<PostAccess>
  author?: Maybe<User>
  createdAt?: Maybe<Scalars['Date']['output']>
  data?: Maybe<Scalars['String']['output']>
  excerpt?: Maybe<Scalars['String']['output']>
  featureImage?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  newsletterAt?: Maybe<Scalars['Date']['output']>
  publishedAt?: Maybe<Scalars['Date']['output']>
  reactionCount?: Maybe<Scalars['Int']['output']>
  slug?: Maybe<Scalars['String']['output']>
  text?: Maybe<Scalars['String']['output']>
  title?: Maybe<Scalars['String']['output']>
  updatedAt?: Maybe<Scalars['Date']['output']>
  viewerHasReacted?: Maybe<Scalars['Boolean']['output']>
}

export enum PostAccess {
  Members = 'MEMBERS',
  PaidMembers = 'PAID_MEMBERS',
  Public = 'PUBLIC',
}

export type Query = {
  __typename?: 'Query'
  bookmark?: Maybe<Bookmark>
  bookmarks: BookmarksConnection
  comment?: Maybe<Comment>
  comments: Array<Maybe<Comment>>
  context: ViewerContext
  emailSubscriptions: EmailSubscriptionsConnection
  homepage?: Maybe<Page>
  page?: Maybe<Page>
  pages: Array<Maybe<Page>>
  post?: Maybe<Post>
  posts: Array<Maybe<Post>>
  question?: Maybe<Question>
  questions: QuestionsConnection
  siteSettings: Site
  siteUsers?: Maybe<Array<SiteUser>>
  tags: Array<Maybe<Tag>>
  user?: Maybe<User>
  userSites?: Maybe<Array<UserSite>>
}

export type QueryBookmarkArgs = {
  id: Scalars['ID']['input']
}

export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  filter?: InputMaybe<BookmarkFilter>
  first?: InputMaybe<Scalars['Int']['input']>
}

export type QueryCommentArgs = {
  id: Scalars['ID']['input']
}

export type QueryCommentsArgs = {
  refId: Scalars['ID']['input']
  type: CommentType
}

export type QueryEmailSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
}

export type QueryPageArgs = {
  slug: Scalars['String']['input']
}

export type QueryPagesArgs = {
  filter?: InputMaybe<PagesFilter>
}

export type QueryPostArgs = {
  slug: Scalars['String']['input']
}

export type QueryPostsArgs = {
  filter?: InputMaybe<WritingFilter>
}

export type QueryQuestionArgs = {
  id: Scalars['ID']['input']
}

export type QueryQuestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  filter?: InputMaybe<QuestionFilter>
  first?: InputMaybe<Scalars['Int']['input']>
}

export type QueryUserArgs = {
  username: Scalars['String']['input']
}

export type Question = {
  __typename?: 'Question'
  author?: Maybe<User>
  createdAt: Scalars['Date']['output']
  description?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  reactionCount?: Maybe<Scalars['Int']['output']>
  status?: Maybe<QuestionStatus>
  title: Scalars['String']['output']
  updatedAt?: Maybe<Scalars['Date']['output']>
  viewerCanComment?: Maybe<Scalars['Boolean']['output']>
  viewerCanEdit?: Maybe<Scalars['Boolean']['output']>
  viewerHasReacted?: Maybe<Scalars['Boolean']['output']>
}

export type QuestionEdge = {
  __typename?: 'QuestionEdge'
  cursor?: Maybe<Scalars['String']['output']>
  node?: Maybe<Question>
}

export type QuestionFilter = {
  status?: InputMaybe<QuestionStatus>
}

export enum QuestionStatus {
  Answered = 'ANSWERED',
  Pending = 'PENDING',
}

export type QuestionsConnection = {
  __typename?: 'QuestionsConnection'
  edges: Array<Maybe<QuestionEdge>>
  pageInfo?: Maybe<PageInfo>
}

export type Reactable = Bookmark | Post | Question

export enum ReactionType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
}

export type SetUserApiKeyInput = {
  clearApiKey?: InputMaybe<Scalars['Boolean']['input']>
  regenApiKey?: InputMaybe<Scalars['Boolean']['input']>
}

export type Site = {
  __typename?: 'Site'
  attach_css?: Maybe<Scalars['String']['output']>
  attach_js?: Maybe<Scalars['String']['output']>
  banner?: Maybe<Scalars['String']['output']>
  chatbot?: Maybe<SiteChatBot>
  description?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  logo?: Maybe<Scalars['String']['output']>
  name?: Maybe<Scalars['String']['output']>
  newsletter_description?: Maybe<Scalars['String']['output']>
  newsletter_double_optin?: Maybe<Scalars['Boolean']['output']>
  newsletter_from_email?: Maybe<Scalars['String']['output']>
  newsletter_provider?: Maybe<Scalars['String']['output']>
  newsletter_setting1?: Maybe<Scalars['String']['output']>
  newsletter_setting2?: Maybe<Scalars['String']['output']>
  newsletter_setting3?: Maybe<Scalars['String']['output']>
  parkedDomain?: Maybe<Scalars['String']['output']>
  plan?: Maybe<Scalars['String']['output']>
  social_github?: Maybe<Scalars['String']['output']>
  social_other1?: Maybe<Scalars['String']['output']>
  social_other1_label?: Maybe<Scalars['String']['output']>
  social_twitter?: Maybe<Scalars['String']['output']>
  social_youtube?: Maybe<Scalars['String']['output']>
  subdomain: Scalars['String']['output']
}

export type SiteChatBot = {
  __typename?: 'SiteChatBot'
  free_quota?: Maybe<Scalars['Int']['output']>
  id: Scalars['ID']['output']
  openai_key?: Maybe<Scalars['String']['output']>
  prompt_template?: Maybe<Scalars['String']['output']>
  site: Site
}

export type SiteOwner = {
  __typename?: 'SiteOwner'
  avatar?: Maybe<Scalars['String']['output']>
  hasEmail?: Maybe<Scalars['Boolean']['output']>
  image?: Maybe<Scalars['String']['output']>
  name?: Maybe<Scalars['String']['output']>
}

export enum SiteRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  Owner = 'OWNER',
  PaidUser = 'PAID_USER',
  User = 'USER',
}

export type SiteUser = {
  __typename?: 'SiteUser'
  id: Scalars['ID']['output']
  siteId?: Maybe<Scalars['String']['output']>
  siteRole?: Maybe<SiteRole>
  user?: Maybe<User>
}

export type Tag = {
  __typename?: 'Tag'
  name: Scalars['String']['output']
}

export type User = {
  __typename?: 'User'
  api_key?: Maybe<Scalars['String']['output']>
  avatar?: Maybe<Scalars['String']['output']>
  createdAt?: Maybe<Scalars['Date']['output']>
  description?: Maybe<Scalars['String']['output']>
  email?: Maybe<Scalars['String']['output']>
  emailSubscriptions?: Maybe<Array<Maybe<UserEmailSubscription>>>
  id: Scalars['ID']['output']
  image?: Maybe<Scalars['String']['output']>
  isAdmin?: Maybe<Scalars['Boolean']['output']>
  location?: Maybe<Scalars['String']['output']>
  name?: Maybe<Scalars['String']['output']>
  pendingEmail?: Maybe<Scalars['String']['output']>
  role?: Maybe<UserRole>
  social_github?: Maybe<Scalars['String']['output']>
  social_other1?: Maybe<Scalars['String']['output']>
  social_other1_label?: Maybe<Scalars['String']['output']>
  social_twitter?: Maybe<Scalars['String']['output']>
  social_youtube?: Maybe<Scalars['String']['output']>
  username?: Maybe<Scalars['String']['output']>
}

export type UserEmailSubscription = {
  __typename?: 'UserEmailSubscription'
  subscribed?: Maybe<Scalars['Boolean']['output']>
  type?: Maybe<EmailSubscriptionType>
}

export enum UserRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type UserSite = {
  __typename?: 'UserSite'
  id: Scalars['ID']['output']
  site?: Maybe<Site>
  siteRole?: Maybe<SiteRole>
  userId?: Maybe<Scalars['String']['output']>
}

export type ViewerContext = {
  __typename?: 'ViewerContext'
  owner?: Maybe<SiteOwner>
  site?: Maybe<Site>
  userSite?: Maybe<UserSite>
  viewer?: Maybe<User>
}

export type WritingFilter = {
  published?: InputMaybe<Scalars['Boolean']['input']>
}

export type BookmarkCoreFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null
  faviconUrl?: string | null
  createdAt: any
  updatedAt: any
}

export type BookmarkListItemFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null
  faviconUrl?: string | null
  createdAt: any
  updatedAt: any
}

export type BookmarkDetailFragment = {
  __typename: 'Bookmark'
  description?: string | null
  html?: string | null
  reactionCount?: number | null
  viewerHasReacted?: boolean | null
  id: string
  url: string
  host: string
  title?: string | null
  faviconUrl?: string | null
  createdAt: any
  updatedAt: any
  tags: Array<{ __typename?: 'Tag'; name: string } | null>
}

export type BookmarksConnectionFragment = {
  __typename?: 'BookmarksConnection'
  pageInfo?: {
    __typename?: 'PageInfo'
    hasNextPage?: boolean | null
    totalCount?: number | null
    endCursor?: string | null
  } | null
  edges: Array<{
    __typename?: 'BookmarkEdge'
    cursor?: string | null
    node?: {
      __typename: 'Bookmark'
      id: string
      url: string
      host: string
      title?: string | null
      faviconUrl?: string | null
      createdAt: any
      updatedAt: any
    } | null
  } | null>
}

export type CommentInfoFragment = {
  __typename: 'Comment'
  id: string
  createdAt: any
  updatedAt?: any | null
  text?: string | null
  viewerCanEdit?: boolean | null
  viewerCanDelete?: boolean | null
  author: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  }
}

export type EmailSubscriptionDetailFragment = {
  __typename: 'EmailSubscription'
  id: string
  email?: string | null
  type?: EmailSubscriptionType | null
  userId?: string | null
}

export type EmailSubscriptionListItemFragment = {
  __typename: 'EmailSubscription'
  id: string
  email?: string | null
  type?: EmailSubscriptionType | null
  userId?: string | null
}

export type EmailSubscriptionsConnectionFragment = {
  __typename?: 'EmailSubscriptionsConnection'
  pageInfo?: {
    __typename?: 'PageInfo'
    hasNextPage?: boolean | null
    totalCount?: number | null
    endCursor?: string | null
  } | null
  edges: Array<{
    __typename?: 'EmailSubscriptionEdge'
    cursor?: string | null
    node?: {
      __typename: 'EmailSubscription'
      id: string
      email?: string | null
      type?: EmailSubscriptionType | null
      userId?: string | null
    } | null
  } | null>
}

export type PageCoreFragment = {
  __typename: 'Page'
  id: string
  publishedAt?: any | null
  title?: string | null
  path?: string | null
  slug?: string | null
  excerpt?: string | null
  featured?: boolean | null
  _isMasked?: boolean | null
}

export type PageListItemFragment = {
  __typename: 'Page'
  id: string
  publishedAt?: any | null
  title?: string | null
  path?: string | null
  slug?: string | null
  excerpt?: string | null
  featured?: boolean | null
  _isMasked?: boolean | null
}

export type PageDetailFragment = {
  __typename: 'Page'
  text?: string | null
  data?: string | null
  featureImage?: string | null
  access?: PageAccess | null
  id: string
  publishedAt?: any | null
  title?: string | null
  path?: string | null
  slug?: string | null
  excerpt?: string | null
  featured?: boolean | null
  _isMasked?: boolean | null
}

export type PostCoreFragment = {
  __typename: 'Post'
  id: string
  publishedAt?: any | null
  title?: string | null
  slug?: string | null
  excerpt?: string | null
  _isMasked?: boolean | null
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type PostListItemFragment = {
  __typename: 'Post'
  id: string
  publishedAt?: any | null
  title?: string | null
  slug?: string | null
  excerpt?: string | null
  _isMasked?: boolean | null
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type PostDetailFragment = {
  __typename: 'Post'
  text?: string | null
  data?: string | null
  featureImage?: string | null
  reactionCount?: number | null
  viewerHasReacted?: boolean | null
  newsletterAt?: any | null
  access?: PostAccess | null
  id: string
  publishedAt?: any | null
  title?: string | null
  slug?: string | null
  excerpt?: string | null
  _isMasked?: boolean | null
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type QuestionCoreFragment = {
  __typename: 'Question'
  id: string
  title: string
  createdAt: any
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type QuestionListItemFragment = {
  __typename: 'Question'
  id: string
  title: string
  createdAt: any
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type QuestionDetailFragment = {
  __typename: 'Question'
  description?: string | null
  status?: QuestionStatus | null
  viewerCanEdit?: boolean | null
  viewerCanComment?: boolean | null
  reactionCount?: number | null
  viewerHasReacted?: boolean | null
  id: string
  title: string
  createdAt: any
  author?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type QuestionsConnectionFragment = {
  __typename?: 'QuestionsConnection'
  pageInfo?: {
    __typename?: 'PageInfo'
    hasNextPage?: boolean | null
    totalCount?: number | null
    endCursor?: string | null
  } | null
  edges: Array<{
    __typename?: 'QuestionEdge'
    cursor?: string | null
    node?: {
      __typename: 'Question'
      id: string
      title: string
      createdAt: any
      author?: {
        __typename: 'User'
        id: string
        username?: string | null
        image?: string | null
        avatar?: string | null
        name?: string | null
        role?: UserRole | null
        isAdmin?: boolean | null
      } | null
    } | null
  } | null>
}

export type SitePublicInfoFragment = {
  __typename: 'Site'
  id: string
  subdomain: string
  parkedDomain?: string | null
  plan?: string | null
  name?: string | null
  description?: string | null
  logo?: string | null
  banner?: string | null
  attach_css?: string | null
  attach_js?: string | null
  social_twitter?: string | null
  social_youtube?: string | null
  social_github?: string | null
  social_other1?: string | null
  social_other1_label?: string | null
  newsletter_description?: string | null
  newsletter_double_optin?: boolean | null
}

export type SiteChatBotInfoFragment = {
  __typename: 'SiteChatBot'
  id: string
  openai_key?: string | null
  prompt_template?: string | null
  free_quota?: number | null
}

export type SiteEditInfoFragment = {
  __typename: 'Site'
  newsletter_provider?: string | null
  newsletter_from_email?: string | null
  newsletter_setting1?: string | null
  newsletter_setting2?: string | null
  newsletter_setting3?: string | null
  id: string
  subdomain: string
  parkedDomain?: string | null
  plan?: string | null
  name?: string | null
  description?: string | null
  logo?: string | null
  banner?: string | null
  attach_css?: string | null
  attach_js?: string | null
  social_twitter?: string | null
  social_youtube?: string | null
  social_github?: string | null
  social_other1?: string | null
  social_other1_label?: string | null
  newsletter_description?: string | null
  newsletter_double_optin?: boolean | null
  chatbot?: {
    __typename: 'SiteChatBot'
    id: string
    openai_key?: string | null
    prompt_template?: string | null
    free_quota?: number | null
  } | null
}

export type UserSiteFragment = {
  __typename?: 'UserSite'
  id: string
  userId?: string | null
  siteRole?: SiteRole | null
  site?: { __typename?: 'Site'; id: string } | null
}

export type UserSiteInfoFragment = {
  __typename?: 'UserSite'
  id: string
  userId?: string | null
  siteRole?: SiteRole | null
  site?: {
    __typename: 'Site'
    id: string
    subdomain: string
    parkedDomain?: string | null
    plan?: string | null
    name?: string | null
    description?: string | null
    logo?: string | null
    banner?: string | null
    attach_css?: string | null
    attach_js?: string | null
    social_twitter?: string | null
    social_youtube?: string | null
    social_github?: string | null
    social_other1?: string | null
    social_other1_label?: string | null
    newsletter_description?: string | null
    newsletter_double_optin?: boolean | null
  } | null
}

export type SiteUserInfoFragment = {
  __typename?: 'SiteUser'
  id: string
  siteRole?: SiteRole | null
  siteId?: string | null
  user?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type UserInfoFragment = {
  __typename: 'User'
  id: string
  username?: string | null
  image?: string | null
  avatar?: string | null
  name?: string | null
  role?: UserRole | null
  isAdmin?: boolean | null
}

export type UserSettingsFragment = {
  __typename?: 'User'
  email?: string | null
  pendingEmail?: string | null
  emailSubscriptions?: Array<{
    __typename?: 'UserEmailSubscription'
    type?: EmailSubscriptionType | null
    subscribed?: boolean | null
  } | null> | null
}

export type UserApiKeyFragment = {
  __typename?: 'User'
  api_key?: string | null
}

export type EditBookmarkMutationVariables = Exact<{
  id: Scalars['ID']['input']
  data: EditBookmarkInput
}>

export type EditBookmarkMutation = {
  __typename?: 'Mutation'
  editBookmark?: {
    __typename: 'Bookmark'
    description?: string | null
    html?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    url: string
    host: string
    title?: string | null
    faviconUrl?: string | null
    createdAt: any
    updatedAt: any
    tags: Array<{ __typename?: 'Tag'; name: string } | null>
  } | null
}

export type DeleteBookmarkMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeleteBookmarkMutation = {
  __typename?: 'Mutation'
  deleteBookmark?: boolean | null
}

export type AddBookmarkMutationVariables = Exact<{
  data: AddBookmarkInput
}>

export type AddBookmarkMutation = {
  __typename?: 'Mutation'
  addBookmark?: {
    __typename: 'Bookmark'
    description?: string | null
    html?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    url: string
    host: string
    title?: string | null
    faviconUrl?: string | null
    createdAt: any
    updatedAt: any
    tags: Array<{ __typename?: 'Tag'; name: string } | null>
  } | null
}

export type AddCommentMutationVariables = Exact<{
  refId: Scalars['ID']['input']
  type: CommentType
  text: Scalars['String']['input']
}>

export type AddCommentMutation = {
  __typename?: 'Mutation'
  addComment?: {
    __typename: 'Comment'
    id: string
    createdAt: any
    updatedAt?: any | null
    text?: string | null
    viewerCanEdit?: boolean | null
    viewerCanDelete?: boolean | null
    author: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    }
  } | null
}

export type EditCommentMutationVariables = Exact<{
  id: Scalars['ID']['input']
  text: Scalars['String']['input']
}>

export type EditCommentMutation = {
  __typename?: 'Mutation'
  editComment?: {
    __typename: 'Comment'
    id: string
    createdAt: any
    updatedAt?: any | null
    text?: string | null
    viewerCanEdit?: boolean | null
    viewerCanDelete?: boolean | null
    author: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    }
  } | null
}

export type DeleteCommentMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeleteCommentMutation = {
  __typename?: 'Mutation'
  deleteComment?: boolean | null
}

export type EditEmailSubscriptionMutationVariables = Exact<{
  data?: InputMaybe<EmailSubscriptionInput>
}>

export type EditEmailSubscriptionMutation = {
  __typename?: 'Mutation'
  editEmailSubscription?: {
    __typename?: 'User'
    emailSubscriptions?: Array<{
      __typename?: 'UserEmailSubscription'
      subscribed?: boolean | null
      type?: EmailSubscriptionType | null
    } | null> | null
  } | null
}

export type EditPageMutationVariables = Exact<{
  id: Scalars['ID']['input']
  data: EditPageInput
}>

export type EditPageMutation = {
  __typename?: 'Mutation'
  editPage?: {
    __typename: 'Page'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    access?: PageAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    path?: string | null
    slug?: string | null
    excerpt?: string | null
    featured?: boolean | null
    _isMasked?: boolean | null
  } | null
}

export type DeletePageMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeletePageMutation = {
  __typename?: 'Mutation'
  deletePage?: boolean | null
}

export type AddPageMutationVariables = Exact<{
  data: AddPageInput
}>

export type AddPageMutation = {
  __typename?: 'Mutation'
  addPage?: {
    __typename: 'Page'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    access?: PageAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    path?: string | null
    slug?: string | null
    excerpt?: string | null
    featured?: boolean | null
    _isMasked?: boolean | null
  } | null
}

export type EditPostMutationVariables = Exact<{
  id: Scalars['ID']['input']
  data: EditPostInput
}>

export type EditPostMutation = {
  __typename?: 'Mutation'
  editPost?: {
    __typename: 'Post'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    newsletterAt?: any | null
    access?: PostAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    slug?: string | null
    excerpt?: string | null
    _isMasked?: boolean | null
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type DeletePostMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeletePostMutation = {
  __typename?: 'Mutation'
  deletePost?: boolean | null
}

export type AddPostMutationVariables = Exact<{
  data: AddPostInput
}>

export type AddPostMutation = {
  __typename?: 'Mutation'
  addPost?: {
    __typename: 'Post'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    newsletterAt?: any | null
    access?: PostAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    slug?: string | null
    excerpt?: string | null
    _isMasked?: boolean | null
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type EditQuestionMutationVariables = Exact<{
  id: Scalars['ID']['input']
  data: EditQuestionInput
}>

export type EditQuestionMutation = {
  __typename?: 'Mutation'
  editQuestion?: {
    __typename: 'Question'
    description?: string | null
    status?: QuestionStatus | null
    viewerCanEdit?: boolean | null
    viewerCanComment?: boolean | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    title: string
    createdAt: any
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type DeleteQuestionMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeleteQuestionMutation = {
  __typename?: 'Mutation'
  deleteQuestion?: boolean | null
}

export type AddQuestionMutationVariables = Exact<{
  data: AddQuestionInput
}>

export type AddQuestionMutation = {
  __typename?: 'Mutation'
  addQuestion?: {
    __typename: 'Question'
    description?: string | null
    status?: QuestionStatus | null
    viewerCanEdit?: boolean | null
    viewerCanComment?: boolean | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    title: string
    createdAt: any
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type ToggleReactionMutationVariables = Exact<{
  refId: Scalars['ID']['input']
  type: ReactionType
}>

export type ToggleReactionMutation = {
  __typename?: 'Mutation'
  toggleReaction?:
    | {
        __typename?: 'Bookmark'
        id: string
        url: string
        reactionCount?: number | null
        viewerHasReacted?: boolean | null
      }
    | {
        __typename?: 'Post'
        id: string
        reactionCount?: number | null
        viewerHasReacted?: boolean | null
      }
    | {
        __typename?: 'Question'
        id: string
        reactionCount?: number | null
        viewerHasReacted?: boolean | null
      }
    | null
}

export type EditSiteDomainMutationVariables = Exact<{
  subdomain: Scalars['String']['input']
  data: EditSiteDomainInput
}>

export type EditSiteDomainMutation = {
  __typename?: 'Mutation'
  editSiteDomain?: {
    __typename: 'Site'
    newsletter_provider?: string | null
    newsletter_from_email?: string | null
    newsletter_setting1?: string | null
    newsletter_setting2?: string | null
    newsletter_setting3?: string | null
    id: string
    subdomain: string
    parkedDomain?: string | null
    plan?: string | null
    name?: string | null
    description?: string | null
    logo?: string | null
    banner?: string | null
    attach_css?: string | null
    attach_js?: string | null
    social_twitter?: string | null
    social_youtube?: string | null
    social_github?: string | null
    social_other1?: string | null
    social_other1_label?: string | null
    newsletter_description?: string | null
    newsletter_double_optin?: boolean | null
    chatbot?: {
      __typename: 'SiteChatBot'
      id: string
      openai_key?: string | null
      prompt_template?: string | null
      free_quota?: number | null
    } | null
  } | null
}

export type EditSiteMutationVariables = Exact<{
  subdomain: Scalars['String']['input']
  data: EditSiteInput
  chatbot?: InputMaybe<EditSiteChatBotInput>
}>

export type EditSiteMutation = {
  __typename?: 'Mutation'
  editSite?: {
    __typename: 'Site'
    newsletter_provider?: string | null
    newsletter_from_email?: string | null
    newsletter_setting1?: string | null
    newsletter_setting2?: string | null
    newsletter_setting3?: string | null
    id: string
    subdomain: string
    parkedDomain?: string | null
    plan?: string | null
    name?: string | null
    description?: string | null
    logo?: string | null
    banner?: string | null
    attach_css?: string | null
    attach_js?: string | null
    social_twitter?: string | null
    social_youtube?: string | null
    social_github?: string | null
    social_other1?: string | null
    social_other1_label?: string | null
    newsletter_description?: string | null
    newsletter_double_optin?: boolean | null
    chatbot?: {
      __typename: 'SiteChatBot'
      id: string
      openai_key?: string | null
      prompt_template?: string | null
      free_quota?: number | null
    } | null
  } | null
}

export type DeleteSiteMutationVariables = Exact<{
  subdomain: Scalars['String']['input']
}>

export type DeleteSiteMutation = {
  __typename?: 'Mutation'
  deleteSite?: boolean | null
}

export type AddSiteMutationVariables = Exact<{
  data: AddSiteInput
}> 

export type AddSiteMutation = {
  __typename?: 'Mutation'
  addSite?: {
    __typename: 'Site'
    newsletter_provider?: string | null
    newsletter_from_email?: string | null
    newsletter_setting1?: string | null
    newsletter_setting2?: string | null
    newsletter_setting3?: string | null
    id: string
    subdomain: string
    parkedDomain?: string | null
    plan?: string | null
    name?: string | null
    description?: string | null
    logo?: string | null
    banner?: string | null
    attach_css?: string | null
    attach_js?: string | null
    social_twitter?: string | null
    social_youtube?: string | null
    social_github?: string | null
    social_other1?: string | null
    social_other1_label?: string | null
    newsletter_description?: string | null
    newsletter_double_optin?: boolean | null
    chatbot?: {
      __typename: 'SiteChatBot'
      id: string
      openai_key?: string | null
      prompt_template?: string | null
      free_quota?: number | null
    } | null
  } | null
}

export type EditSiteUserMutationVariables = Exact<{
  data: EditSiteUserInput
}>

export type EditSiteUserMutation = {
  __typename?: 'Mutation'
  editSiteUser?: { __typename?: 'SiteUser'; siteRole?: SiteRole | null } | null
}

export type DeleteUserMutationVariables = Exact<{ [key: string]: never }>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: boolean | null
}

export type EditUserMutationVariables = Exact<{
  data?: InputMaybe<EditUserInput>
}>

export type EditUserMutation = {
  __typename?: 'Mutation'
  editUser?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type SetUserApiKeyMutationVariables = Exact<{
  data?: InputMaybe<SetUserApiKeyInput>
}>

export type SetUserApiKeyMutation = {
  __typename?: 'Mutation'
  setUserApiKey?: { __typename?: 'User'; api_key?: string | null } | null
}

export type GetBookmarksQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>
  after?: InputMaybe<Scalars['String']['input']>
  filter?: InputMaybe<BookmarkFilter>
}>

export type GetBookmarksQuery = {
  __typename?: 'Query'
  bookmarks: {
    __typename?: 'BookmarksConnection'
    pageInfo?: {
      __typename?: 'PageInfo'
      hasNextPage?: boolean | null
      totalCount?: number | null
      endCursor?: string | null
    } | null
    edges: Array<{
      __typename?: 'BookmarkEdge'
      cursor?: string | null
      node?: {
        __typename: 'Bookmark'
        id: string
        url: string
        host: string
        title?: string | null
        faviconUrl?: string | null
        createdAt: any
        updatedAt: any
      } | null
    } | null>
  }
}

export type GetBookmarkQueryVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type GetBookmarkQuery = {
  __typename?: 'Query'
  bookmark?: {
    __typename: 'Bookmark'
    description?: string | null
    html?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    url: string
    host: string
    title?: string | null
    faviconUrl?: string | null
    createdAt: any
    updatedAt: any
    tags: Array<{ __typename?: 'Tag'; name: string } | null>
  } | null
}

export type GetCommentsQueryVariables = Exact<{
  refId: Scalars['ID']['input']
  type: CommentType
}>

export type GetCommentsQuery = {
  __typename?: 'Query'
  comments: Array<{
    __typename: 'Comment'
    id: string
    createdAt: any
    updatedAt?: any | null
    text?: string | null
    viewerCanEdit?: boolean | null
    viewerCanDelete?: boolean | null
    author: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    }
  } | null>
}

export type GetEmailSubscriptionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>
  after?: InputMaybe<Scalars['String']['input']>
}>

export type GetEmailSubscriptionsQuery = {
  __typename?: 'Query'
  emailSubscriptions: {
    __typename?: 'EmailSubscriptionsConnection'
    pageInfo?: {
      __typename?: 'PageInfo'
      hasNextPage?: boolean | null
      totalCount?: number | null
      endCursor?: string | null
    } | null
    edges: Array<{
      __typename?: 'EmailSubscriptionEdge'
      cursor?: string | null
      node?: {
        __typename: 'EmailSubscription'
        id: string
        email?: string | null
        type?: EmailSubscriptionType | null
        userId?: string | null
      } | null
    } | null>
  }
}

export type GetPagesQueryVariables = Exact<{
  filter?: InputMaybe<PagesFilter>
}>

export type GetPagesQuery = {
  __typename?: 'Query'
  pages: Array<{
    __typename: 'Page'
    id: string
    publishedAt?: any | null
    title?: string | null
    path?: string | null
    slug?: string | null
    excerpt?: string | null
    featured?: boolean | null
    _isMasked?: boolean | null
  } | null>
}

export type GetPageQueryVariables = Exact<{
  slug: Scalars['String']['input']
}>

export type GetPageQuery = {
  __typename?: 'Query'
  page?: {
    __typename: 'Page'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    access?: PageAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    path?: string | null
    slug?: string | null
    excerpt?: string | null
    featured?: boolean | null
    _isMasked?: boolean | null
  } | null
}

export type GetHomePageQueryVariables = Exact<{ [key: string]: never }>

export type GetHomePageQuery = {
  __typename?: 'Query'
  homepage?: {
    __typename: 'Page'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    access?: PageAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    path?: string | null
    slug?: string | null
    excerpt?: string | null
    featured?: boolean | null
    _isMasked?: boolean | null
  } | null
}

export type GetPostsQueryVariables = Exact<{
  filter?: InputMaybe<WritingFilter>
}>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts: Array<{
    __typename: 'Post'
    id: string
    publishedAt?: any | null
    title?: string | null
    slug?: string | null
    excerpt?: string | null
    _isMasked?: boolean | null
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null>
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']['input']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?: {
    __typename: 'Post'
    text?: string | null
    data?: string | null
    featureImage?: string | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    newsletterAt?: any | null
    access?: PostAccess | null
    id: string
    publishedAt?: any | null
    title?: string | null
    slug?: string | null
    excerpt?: string | null
    _isMasked?: boolean | null
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type GetQuestionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>
  after?: InputMaybe<Scalars['String']['input']>
  filter?: InputMaybe<QuestionFilter>
}>

export type GetQuestionsQuery = {
  __typename?: 'Query'
  questions: {
    __typename?: 'QuestionsConnection'
    pageInfo?: {
      __typename?: 'PageInfo'
      hasNextPage?: boolean | null
      totalCount?: number | null
      endCursor?: string | null
    } | null
    edges: Array<{
      __typename?: 'QuestionEdge'
      cursor?: string | null
      node?: {
        __typename: 'Question'
        id: string
        title: string
        createdAt: any
        author?: {
          __typename: 'User'
          id: string
          username?: string | null
          image?: string | null
          avatar?: string | null
          name?: string | null
          role?: UserRole | null
          isAdmin?: boolean | null
        } | null
      } | null
    } | null>
  }
}

export type GetQuestionQueryVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type GetQuestionQuery = {
  __typename?: 'Query'
  question?: {
    __typename: 'Question'
    description?: string | null
    status?: QuestionStatus | null
    viewerCanEdit?: boolean | null
    viewerCanComment?: boolean | null
    reactionCount?: number | null
    viewerHasReacted?: boolean | null
    id: string
    title: string
    createdAt: any
    author?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  } | null
}

export type GetSiteSettingsQueryVariables = Exact<{ [key: string]: never }>

export type GetSiteSettingsQuery = {
  __typename?: 'Query'
  siteSettings: {
    __typename: 'Site'
    newsletter_provider?: string | null
    newsletter_from_email?: string | null
    newsletter_setting1?: string | null
    newsletter_setting2?: string | null
    newsletter_setting3?: string | null
    id: string
    subdomain: string
    parkedDomain?: string | null
    plan?: string | null
    name?: string | null
    description?: string | null
    logo?: string | null
    banner?: string | null
    attach_css?: string | null
    attach_js?: string | null
    social_twitter?: string | null
    social_youtube?: string | null
    social_github?: string | null
    social_other1?: string | null
    social_other1_label?: string | null
    newsletter_description?: string | null
    newsletter_double_optin?: boolean | null
    chatbot?: {
      __typename: 'SiteChatBot'
      id: string
      openai_key?: string | null
      prompt_template?: string | null
      free_quota?: number | null
    } | null
  }
}

export type GetUserSitesQueryVariables = Exact<{ [key: string]: never }>

export type GetUserSitesQuery = {
  __typename?: 'Query'
  userSites?: Array<{
    __typename?: 'UserSite'
    id: string
    userId?: string | null
    siteRole?: SiteRole | null
    site?: {
      __typename: 'Site'
      id: string
      subdomain: string
      parkedDomain?: string | null
      plan?: string | null
      name?: string | null
      description?: string | null
      logo?: string | null
      banner?: string | null
      attach_css?: string | null
      attach_js?: string | null
      social_twitter?: string | null
      social_youtube?: string | null
      social_github?: string | null
      social_other1?: string | null
      social_other1_label?: string | null
      newsletter_description?: string | null
      newsletter_double_optin?: boolean | null
    } | null
  }> | null
}

export type GetSiteUsersQueryVariables = Exact<{ [key: string]: never }>

export type GetSiteUsersQuery = {
  __typename?: 'Query'
  siteUsers?: Array<{
    __typename?: 'SiteUser'
    id: string
    siteRole?: SiteRole | null
    siteId?: string | null
    user?: {
      __typename: 'User'
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
  }> | null
}

export type GetTagsQueryVariables = Exact<{ [key: string]: never }>

export type GetTagsQuery = {
  __typename?: 'Query'
  tags: Array<{ __typename?: 'Tag'; name: string } | null>
}

export type GetUserQueryVariables = Exact<{
  username: Scalars['String']['input']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?: {
    __typename: 'User'
    id: string
    username?: string | null
    image?: string | null
    avatar?: string | null
    name?: string | null
    role?: UserRole | null
    isAdmin?: boolean | null
  } | null
}

export type GetViewerWithSettingsQueryVariables = Exact<{
  [key: string]: never
}>

export type GetViewerWithSettingsQuery = {
  __typename?: 'Query'
  context: {
    __typename?: 'ViewerContext'
    viewer?: {
      __typename: 'User'
      email?: string | null
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
      pendingEmail?: string | null
      api_key?: string | null
      emailSubscriptions?: Array<{
        __typename?: 'UserEmailSubscription'
        type?: EmailSubscriptionType | null
        subscribed?: boolean | null
      } | null> | null
    } | null
  }
}

export type ContextQueryVariables = Exact<{ [key: string]: never }>

export type ContextQuery = {
  __typename?: 'Query'
  context: {
    __typename?: 'ViewerContext'
    viewer?: {
      __typename: 'User'
      email?: string | null
      id: string
      username?: string | null
      image?: string | null
      avatar?: string | null
      name?: string | null
      role?: UserRole | null
      isAdmin?: boolean | null
    } | null
    site?: {
      __typename: 'Site'
      id: string
      subdomain: string
      parkedDomain?: string | null
      plan?: string | null
      name?: string | null
      description?: string | null
      logo?: string | null
      banner?: string | null
      attach_css?: string | null
      attach_js?: string | null
      social_twitter?: string | null
      social_youtube?: string | null
      social_github?: string | null
      social_other1?: string | null
      social_other1_label?: string | null
      newsletter_description?: string | null
      newsletter_double_optin?: boolean | null
    } | null
    userSite?: {
      __typename?: 'UserSite'
      id: string
      userId?: string | null
      siteRole?: SiteRole | null
      site?: { __typename?: 'Site'; id: string } | null
    } | null
    owner?: {
      __typename?: 'SiteOwner'
      image?: string | null
      avatar?: string | null
      hasEmail?: boolean | null
      name?: string | null
    } | null
  }
}

export const BookmarkCoreFragmentDoc = gql`
  fragment BookmarkCore on Bookmark {
    __typename
    id
    url
    host
    title
    faviconUrl
    createdAt
    updatedAt
  }
`
export const BookmarkDetailFragmentDoc = gql`
  fragment BookmarkDetail on Bookmark {
    ...BookmarkCore
    description
    html
    reactionCount
    viewerHasReacted
    tags {
      name
    }
  }
  ${BookmarkCoreFragmentDoc}
`
export const BookmarkListItemFragmentDoc = gql`
  fragment BookmarkListItem on Bookmark {
    ...BookmarkCore
  }
  ${BookmarkCoreFragmentDoc}
`
export const BookmarksConnectionFragmentDoc = gql`
  fragment BookmarksConnection on BookmarksConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...BookmarkListItem
      }
    }
  }
  ${BookmarkListItemFragmentDoc}
`
export const UserInfoFragmentDoc = gql`
  fragment UserInfo on User {
    __typename
    id
    username
    image
    avatar
    name
    role
    isAdmin
  }
`
export const CommentInfoFragmentDoc = gql`
  fragment CommentInfo on Comment {
    __typename
    id
    createdAt
    updatedAt
    text
    viewerCanEdit
    viewerCanDelete
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const EmailSubscriptionDetailFragmentDoc = gql`
  fragment EmailSubscriptionDetail on EmailSubscription {
    __typename
    id
    email
    type
    userId
  }
`
export const EmailSubscriptionListItemFragmentDoc = gql`
  fragment EmailSubscriptionListItem on EmailSubscription {
    ...EmailSubscriptionDetail
  }
  ${EmailSubscriptionDetailFragmentDoc}
`
export const EmailSubscriptionsConnectionFragmentDoc = gql`
  fragment EmailSubscriptionsConnection on EmailSubscriptionsConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...EmailSubscriptionListItem
      }
    }
  }
  ${EmailSubscriptionListItemFragmentDoc}
`
export const PageCoreFragmentDoc = gql`
  fragment PageCore on Page {
    __typename
    id
    publishedAt
    title
    path
    slug
    excerpt
    featured
    _isMasked
  }
`
export const PageListItemFragmentDoc = gql`
  fragment PageListItem on Page {
    ...PageCore
  }
  ${PageCoreFragmentDoc}
`
export const PageDetailFragmentDoc = gql`
  fragment PageDetail on Page {
    ...PageCore
    text
    data
    featureImage
    access
  }
  ${PageCoreFragmentDoc}
`
export const PostCoreFragmentDoc = gql`
  fragment PostCore on Post {
    __typename
    id
    publishedAt
    title
    slug
    excerpt
    author {
      ...UserInfo
    }
    _isMasked
  }
  ${UserInfoFragmentDoc}
`
export const PostListItemFragmentDoc = gql`
  fragment PostListItem on Post {
    ...PostCore
  }
  ${PostCoreFragmentDoc}
`
export const PostDetailFragmentDoc = gql`
  fragment PostDetail on Post {
    ...PostCore
    text
    data
    featureImage
    reactionCount
    viewerHasReacted
    newsletterAt
    access
  }
  ${PostCoreFragmentDoc}
`
export const QuestionCoreFragmentDoc = gql`
  fragment QuestionCore on Question {
    __typename
    id
    title
    createdAt
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const QuestionDetailFragmentDoc = gql`
  fragment QuestionDetail on Question {
    ...QuestionCore
    description
    status
    viewerCanEdit
    viewerCanComment
    reactionCount
    viewerHasReacted
  }
  ${QuestionCoreFragmentDoc}
`
export const QuestionListItemFragmentDoc = gql`
  fragment QuestionListItem on Question {
    ...QuestionCore
  }
  ${QuestionCoreFragmentDoc}
`
export const QuestionsConnectionFragmentDoc = gql`
  fragment QuestionsConnection on QuestionsConnection {
    pageInfo {
      hasNextPage
      totalCount
      endCursor
    }
    edges {
      cursor
      node {
        ...QuestionListItem
      }
    }
  }
  ${QuestionListItemFragmentDoc}
`
export const SitePublicInfoFragmentDoc = gql`
  fragment SitePublicInfo on Site {
    __typename
    id
    subdomain
    parkedDomain
    plan
    name
    description
    logo
    banner
    attach_css
    attach_js
    social_twitter
    social_youtube
    social_github
    social_other1
    social_other1_label
    newsletter_description
    newsletter_double_optin
  }
`
export const SiteChatBotInfoFragmentDoc = gql`
  fragment SiteChatBotInfo on SiteChatBot {
    __typename
    id
    openai_key
    prompt_template
    free_quota
  }
`
export const SiteEditInfoFragmentDoc = gql`
  fragment SiteEditInfo on Site {
    ...SitePublicInfo
    newsletter_provider
    newsletter_from_email
    newsletter_setting1
    newsletter_setting2
    newsletter_setting3
    chatbot {
      ...SiteChatBotInfo
    }
  }
  ${SitePublicInfoFragmentDoc}
  ${SiteChatBotInfoFragmentDoc}
`
export const UserSiteFragmentDoc = gql`
  fragment UserSite on UserSite {
    id
    userId
    siteRole
    site {
      id
    }
  }
`
export const UserSiteInfoFragmentDoc = gql`
  fragment UserSiteInfo on UserSite {
    id
    userId
    siteRole
    site {
      ...SitePublicInfo
    }
  }
  ${SitePublicInfoFragmentDoc}
`
export const SiteUserInfoFragmentDoc = gql`
  fragment SiteUserInfo on SiteUser {
    id
    user {
      ...UserInfo
    }
    siteRole
    siteId
  }
  ${UserInfoFragmentDoc}
`
export const UserSettingsFragmentDoc = gql`
  fragment UserSettings on User {
    email
    pendingEmail
    emailSubscriptions {
      type
      subscribed
    }
  }
`
export const UserApiKeyFragmentDoc = gql`
  fragment UserApiKey on User {
    api_key
  }
`
export const EditBookmarkDocument = gql`
  mutation editBookmark($id: ID!, $data: EditBookmarkInput!) {
    editBookmark(id: $id, data: $data) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`
export type EditBookmarkMutationFn = Apollo.MutationFunction<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>

/**
 * __useEditBookmarkMutation__
 *
 * To run a mutation, you first call `useEditBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookmarkMutation, { data, loading, error }] = useEditBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >(EditBookmarkDocument, options)
}
export type EditBookmarkMutationHookResult = ReturnType<
  typeof useEditBookmarkMutation
>
export type EditBookmarkMutationResult =
  Apollo.MutationResult<EditBookmarkMutation>
export type EditBookmarkMutationOptions = Apollo.BaseMutationOptions<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>
export const DeleteBookmarkDocument = gql`
  mutation deleteBookmark($id: ID!) {
    deleteBookmark(id: $id)
  }
`
export type DeleteBookmarkMutationFn = Apollo.MutationFunction<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>

/**
 * __useDeleteBookmarkMutation__
 *
 * To run a mutation, you first call `useDeleteBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookmarkMutation, { data, loading, error }] = useDeleteBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >(DeleteBookmarkDocument, options)
}
export type DeleteBookmarkMutationHookResult = ReturnType<
  typeof useDeleteBookmarkMutation
>
export type DeleteBookmarkMutationResult =
  Apollo.MutationResult<DeleteBookmarkMutation>
export type DeleteBookmarkMutationOptions = Apollo.BaseMutationOptions<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>
export const AddBookmarkDocument = gql`
  mutation addBookmark($data: AddBookmarkInput!) {
    addBookmark(data: $data) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`
export type AddBookmarkMutationFn = Apollo.MutationFunction<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>

/**
 * __useAddBookmarkMutation__
 *
 * To run a mutation, you first call `useAddBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkMutation, { data, loading, error }] = useAddBookmarkMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddBookmarkMutation,
    AddBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddBookmarkMutation, AddBookmarkMutationVariables>(
    AddBookmarkDocument,
    options
  )
}
export type AddBookmarkMutationHookResult = ReturnType<
  typeof useAddBookmarkMutation
>
export type AddBookmarkMutationResult =
  Apollo.MutationResult<AddBookmarkMutation>
export type AddBookmarkMutationOptions = Apollo.BaseMutationOptions<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>
export const AddCommentDocument = gql`
  mutation addComment($refId: ID!, $type: CommentType!, $text: String!) {
    addComment(refId: $refId, type: $type, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type AddCommentMutationFn = Apollo.MutationFunction<
  AddCommentMutation,
  AddCommentMutationVariables
>

/**
 * __useAddCommentMutation__
 *
 * To run a mutation, you first call `useAddCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCommentMutation, { data, loading, error }] = useAddCommentMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useAddCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddCommentMutation,
    AddCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddCommentMutation, AddCommentMutationVariables>(
    AddCommentDocument,
    options
  )
}
export type AddCommentMutationHookResult = ReturnType<
  typeof useAddCommentMutation
>
export type AddCommentMutationResult = Apollo.MutationResult<AddCommentMutation>
export type AddCommentMutationOptions = Apollo.BaseMutationOptions<
  AddCommentMutation,
  AddCommentMutationVariables
>
export const EditCommentDocument = gql`
  mutation editComment($id: ID!, $text: String!) {
    editComment(id: $id, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type EditCommentMutationFn = Apollo.MutationFunction<
  EditCommentMutation,
  EditCommentMutationVariables
>

/**
 * __useEditCommentMutation__
 *
 * To run a mutation, you first call `useEditCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCommentMutation, { data, loading, error }] = useEditCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useEditCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditCommentMutation,
    EditCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditCommentMutation, EditCommentMutationVariables>(
    EditCommentDocument,
    options
  )
}
export type EditCommentMutationHookResult = ReturnType<
  typeof useEditCommentMutation
>
export type EditCommentMutationResult =
  Apollo.MutationResult<EditCommentMutation>
export type EditCommentMutationOptions = Apollo.BaseMutationOptions<
  EditCommentMutation,
  EditCommentMutationVariables
>
export const DeleteCommentDocument = gql`
  mutation deleteComment($id: ID!) {
    deleteComment(id: $id)
  }
`
export type DeleteCommentMutationFn = Apollo.MutationFunction<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >(DeleteCommentDocument, options)
}
export type DeleteCommentMutationHookResult = ReturnType<
  typeof useDeleteCommentMutation
>
export type DeleteCommentMutationResult =
  Apollo.MutationResult<DeleteCommentMutation>
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>
export const EditEmailSubscriptionDocument = gql`
  mutation editEmailSubscription($data: EmailSubscriptionInput) {
    editEmailSubscription(data: $data) {
      emailSubscriptions {
        subscribed
        type
      }
    }
  }
`
export type EditEmailSubscriptionMutationFn = Apollo.MutationFunction<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>

/**
 * __useEditEmailSubscriptionMutation__
 *
 * To run a mutation, you first call `useEditEmailSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditEmailSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editEmailSubscriptionMutation, { data, loading, error }] = useEditEmailSubscriptionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditEmailSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >(EditEmailSubscriptionDocument, options)
}
export type EditEmailSubscriptionMutationHookResult = ReturnType<
  typeof useEditEmailSubscriptionMutation
>
export type EditEmailSubscriptionMutationResult =
  Apollo.MutationResult<EditEmailSubscriptionMutation>
export type EditEmailSubscriptionMutationOptions = Apollo.BaseMutationOptions<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>
export const EditPageDocument = gql`
  mutation editPage($id: ID!, $data: EditPageInput!) {
    editPage(id: $id, data: $data) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`
export type EditPageMutationFn = Apollo.MutationFunction<
  EditPageMutation,
  EditPageMutationVariables
>

/**
 * __useEditPageMutation__
 *
 * To run a mutation, you first call `useEditPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPageMutation, { data, loading, error }] = useEditPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditPageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditPageMutation,
    EditPageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditPageMutation, EditPageMutationVariables>(
    EditPageDocument,
    options
  )
}
export type EditPageMutationHookResult = ReturnType<typeof useEditPageMutation>
export type EditPageMutationResult = Apollo.MutationResult<EditPageMutation>
export type EditPageMutationOptions = Apollo.BaseMutationOptions<
  EditPageMutation,
  EditPageMutationVariables
>
export const DeletePageDocument = gql`
  mutation deletePage($id: ID!) {
    deletePage(id: $id)
  }
`
export type DeletePageMutationFn = Apollo.MutationFunction<
  DeletePageMutation,
  DeletePageMutationVariables
>

/**
 * __useDeletePageMutation__
 *
 * To run a mutation, you first call `useDeletePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePageMutation, { data, loading, error }] = useDeletePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePageMutation,
    DeletePageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePageMutation, DeletePageMutationVariables>(
    DeletePageDocument,
    options
  )
}
export type DeletePageMutationHookResult = ReturnType<
  typeof useDeletePageMutation
>
export type DeletePageMutationResult = Apollo.MutationResult<DeletePageMutation>
export type DeletePageMutationOptions = Apollo.BaseMutationOptions<
  DeletePageMutation,
  DeletePageMutationVariables
>
export const AddPageDocument = gql`
  mutation addPage($data: AddPageInput!) {
    addPage(data: $data) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`
export type AddPageMutationFn = Apollo.MutationFunction<
  AddPageMutation,
  AddPageMutationVariables
>

/**
 * __useAddPageMutation__
 *
 * To run a mutation, you first call `useAddPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPageMutation, { data, loading, error }] = useAddPageMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddPageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddPageMutation,
    AddPageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddPageMutation, AddPageMutationVariables>(
    AddPageDocument,
    options
  )
}
export type AddPageMutationHookResult = ReturnType<typeof useAddPageMutation>
export type AddPageMutationResult = Apollo.MutationResult<AddPageMutation>
export type AddPageMutationOptions = Apollo.BaseMutationOptions<
  AddPageMutation,
  AddPageMutationVariables
>
export const EditPostDocument = gql`
  mutation editPost($id: ID!, $data: EditPostInput!) {
    editPost(id: $id, data: $data) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`
export type EditPostMutationFn = Apollo.MutationFunction<
  EditPostMutation,
  EditPostMutationVariables
>

/**
 * __useEditPostMutation__
 *
 * To run a mutation, you first call `useEditPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPostMutation, { data, loading, error }] = useEditPostMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditPostMutation,
    EditPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditPostMutation, EditPostMutationVariables>(
    EditPostDocument,
    options
  )
}
export type EditPostMutationHookResult = ReturnType<typeof useEditPostMutation>
export type EditPostMutationResult = Apollo.MutationResult<EditPostMutation>
export type EditPostMutationOptions = Apollo.BaseMutationOptions<
  EditPostMutation,
  EditPostMutationVariables
>
export const DeletePostDocument = gql`
  mutation deletePost($id: ID!) {
    deletePost(id: $id)
  }
`
export type DeletePostMutationFn = Apollo.MutationFunction<
  DeletePostMutation,
  DeletePostMutationVariables
>

/**
 * __useDeletePostMutation__
 *
 * To run a mutation, you first call `useDeletePostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePostMutation, { data, loading, error }] = useDeletePostMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeletePostMutation,
    DeletePostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeletePostMutation, DeletePostMutationVariables>(
    DeletePostDocument,
    options
  )
}
export type DeletePostMutationHookResult = ReturnType<
  typeof useDeletePostMutation
>
export type DeletePostMutationResult = Apollo.MutationResult<DeletePostMutation>
export type DeletePostMutationOptions = Apollo.BaseMutationOptions<
  DeletePostMutation,
  DeletePostMutationVariables
>
export const AddPostDocument = gql`
  mutation addPost($data: AddPostInput!) {
    addPost(data: $data) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`
export type AddPostMutationFn = Apollo.MutationFunction<
  AddPostMutation,
  AddPostMutationVariables
>

/**
 * __useAddPostMutation__
 *
 * To run a mutation, you first call `useAddPostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPostMutation, { data, loading, error }] = useAddPostMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddPostMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddPostMutation,
    AddPostMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddPostMutation, AddPostMutationVariables>(
    AddPostDocument,
    options
  )
}
export type AddPostMutationHookResult = ReturnType<typeof useAddPostMutation>
export type AddPostMutationResult = Apollo.MutationResult<AddPostMutation>
export type AddPostMutationOptions = Apollo.BaseMutationOptions<
  AddPostMutation,
  AddPostMutationVariables
>
export const EditQuestionDocument = gql`
  mutation editQuestion($id: ID!, $data: EditQuestionInput!) {
    editQuestion(id: $id, data: $data) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`
export type EditQuestionMutationFn = Apollo.MutationFunction<
  EditQuestionMutation,
  EditQuestionMutationVariables
>

/**
 * __useEditQuestionMutation__
 *
 * To run a mutation, you first call `useEditQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editQuestionMutation, { data, loading, error }] = useEditQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >(EditQuestionDocument, options)
}
export type EditQuestionMutationHookResult = ReturnType<
  typeof useEditQuestionMutation
>
export type EditQuestionMutationResult =
  Apollo.MutationResult<EditQuestionMutation>
export type EditQuestionMutationOptions = Apollo.BaseMutationOptions<
  EditQuestionMutation,
  EditQuestionMutationVariables
>
export const DeleteQuestionDocument = gql`
  mutation deleteQuestion($id: ID!) {
    deleteQuestion(id: $id)
  }
`
export type DeleteQuestionMutationFn = Apollo.MutationFunction<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>

/**
 * __useDeleteQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteQuestionMutation, { data, loading, error }] = useDeleteQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >(DeleteQuestionDocument, options)
}
export type DeleteQuestionMutationHookResult = ReturnType<
  typeof useDeleteQuestionMutation
>
export type DeleteQuestionMutationResult =
  Apollo.MutationResult<DeleteQuestionMutation>
export type DeleteQuestionMutationOptions = Apollo.BaseMutationOptions<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>
export const AddQuestionDocument = gql`
  mutation addQuestion($data: AddQuestionInput!) {
    addQuestion(data: $data) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`
export type AddQuestionMutationFn = Apollo.MutationFunction<
  AddQuestionMutation,
  AddQuestionMutationVariables
>

/**
 * __useAddQuestionMutation__
 *
 * To run a mutation, you first call `useAddQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addQuestionMutation, { data, loading, error }] = useAddQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddQuestionMutation,
    AddQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddQuestionMutation, AddQuestionMutationVariables>(
    AddQuestionDocument,
    options
  )
}
export type AddQuestionMutationHookResult = ReturnType<
  typeof useAddQuestionMutation
>
export type AddQuestionMutationResult =
  Apollo.MutationResult<AddQuestionMutation>
export type AddQuestionMutationOptions = Apollo.BaseMutationOptions<
  AddQuestionMutation,
  AddQuestionMutationVariables
>
export const ToggleReactionDocument = gql`
  mutation toggleReaction($refId: ID!, $type: ReactionType!) {
    toggleReaction(refId: $refId, type: $type) {
      ... on Bookmark {
        id
        url
        reactionCount
        viewerHasReacted
      }
      ... on Question {
        id
        reactionCount
        viewerHasReacted
      }
      ... on Post {
        id
        reactionCount
        viewerHasReacted
      }
    }
  }
`
export type ToggleReactionMutationFn = Apollo.MutationFunction<
  ToggleReactionMutation,
  ToggleReactionMutationVariables
>

/**
 * __useToggleReactionMutation__
 *
 * To run a mutation, you first call `useToggleReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useToggleReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [toggleReactionMutation, { data, loading, error }] = useToggleReactionMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useToggleReactionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ToggleReactionMutation,
    ToggleReactionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    ToggleReactionMutation,
    ToggleReactionMutationVariables
  >(ToggleReactionDocument, options)
}
export type ToggleReactionMutationHookResult = ReturnType<
  typeof useToggleReactionMutation
>
export type ToggleReactionMutationResult =
  Apollo.MutationResult<ToggleReactionMutation>
export type ToggleReactionMutationOptions = Apollo.BaseMutationOptions<
  ToggleReactionMutation,
  ToggleReactionMutationVariables
>
export const EditSiteDomainDocument = gql`
  mutation editSiteDomain($subdomain: String!, $data: EditSiteDomainInput!) {
    editSiteDomain(subdomain: $subdomain, data: $data) {
      ...SiteEditInfo
    }
  }
  ${SiteEditInfoFragmentDoc}
`
export type EditSiteDomainMutationFn = Apollo.MutationFunction<
  EditSiteDomainMutation,
  EditSiteDomainMutationVariables
>

/**
 * __useEditSiteDomainMutation__
 *
 * To run a mutation, you first call `useEditSiteDomainMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSiteDomainMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSiteDomainMutation, { data, loading, error }] = useEditSiteDomainMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditSiteDomainMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSiteDomainMutation,
    EditSiteDomainMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditSiteDomainMutation,
    EditSiteDomainMutationVariables
  >(EditSiteDomainDocument, options)
}
export type EditSiteDomainMutationHookResult = ReturnType<
  typeof useEditSiteDomainMutation
>
export type EditSiteDomainMutationResult =
  Apollo.MutationResult<EditSiteDomainMutation>
export type EditSiteDomainMutationOptions = Apollo.BaseMutationOptions<
  EditSiteDomainMutation,
  EditSiteDomainMutationVariables
>
export const EditSiteDocument = gql`
  mutation editSite(
    $subdomain: String!
    $data: EditSiteInput!
    $chatbot: EditSiteChatBotInput
  ) {
    editSite(subdomain: $subdomain, data: $data, chatbot: $chatbot) {
      ...SiteEditInfo
    }
  }
  ${SiteEditInfoFragmentDoc}
`
export type EditSiteMutationFn = Apollo.MutationFunction<
  EditSiteMutation,
  EditSiteMutationVariables
>

/**
 * __useEditSiteMutation__
 *
 * To run a mutation, you first call `useEditSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSiteMutation, { data, loading, error }] = useEditSiteMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *      data: // value for 'data'
 *      chatbot: // value for 'chatbot'
 *   },
 * });
 */
export function useEditSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSiteMutation,
    EditSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditSiteMutation, EditSiteMutationVariables>(
    EditSiteDocument,
    options
  )
}
export type EditSiteMutationHookResult = ReturnType<typeof useEditSiteMutation>
export type EditSiteMutationResult = Apollo.MutationResult<EditSiteMutation>
export type EditSiteMutationOptions = Apollo.BaseMutationOptions<
  EditSiteMutation,
  EditSiteMutationVariables
>
export const DeleteSiteDocument = gql`
  mutation deleteSite($subdomain: String!) {
    deleteSite(subdomain: $subdomain)
  }
`
export type DeleteSiteMutationFn = Apollo.MutationFunction<
  DeleteSiteMutation,
  DeleteSiteMutationVariables
>

/**
 * __useDeleteSiteMutation__
 *
 * To run a mutation, you first call `useDeleteSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSiteMutation, { data, loading, error }] = useDeleteSiteMutation({
 *   variables: {
 *      subdomain: // value for 'subdomain'
 *   },
 * });
 */
export function useDeleteSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteSiteMutation,
    DeleteSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteSiteMutation, DeleteSiteMutationVariables>(
    DeleteSiteDocument,
    options
  )
}
export type DeleteSiteMutationHookResult = ReturnType<
  typeof useDeleteSiteMutation
>
export type DeleteSiteMutationResult = Apollo.MutationResult<DeleteSiteMutation>
export type DeleteSiteMutationOptions = Apollo.BaseMutationOptions<
  DeleteSiteMutation,
  DeleteSiteMutationVariables
>
export const AddSiteDocument = gql`
  mutation addSite($data: AddSiteInput!) {
    addSite(data: $data) {
      ...SiteEditInfo
    }
  }
  ${SiteEditInfoFragmentDoc}
`
export type AddSiteMutationFn = Apollo.MutationFunction<
  AddSiteMutation,
  AddSiteMutationVariables
>

/**
 * __useAddSiteMutation__
 *
 * To run a mutation, you first call `useAddSiteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddSiteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addSiteMutation, { data, loading, error }] = useAddSiteMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddSiteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddSiteMutation,
    AddSiteMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddSiteMutation, AddSiteMutationVariables>(
    AddSiteDocument,
    options
  )
}
export type AddSiteMutationHookResult = ReturnType<typeof useAddSiteMutation>
export type AddSiteMutationResult = Apollo.MutationResult<AddSiteMutation>
export type AddSiteMutationOptions = Apollo.BaseMutationOptions<
  AddSiteMutation,
  AddSiteMutationVariables
>
export const EditSiteUserDocument = gql`
  mutation editSiteUser($data: EditSiteUserInput!) {
    editSiteUser(data: $data) {
      siteRole
    }
  }
`
export type EditSiteUserMutationFn = Apollo.MutationFunction<
  EditSiteUserMutation,
  EditSiteUserMutationVariables
>

/**
 * __useEditSiteUserMutation__
 *
 * To run a mutation, you first call `useEditSiteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSiteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSiteUserMutation, { data, loading, error }] = useEditSiteUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditSiteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSiteUserMutation,
    EditSiteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditSiteUserMutation,
    EditSiteUserMutationVariables
  >(EditSiteUserDocument, options)
}
export type EditSiteUserMutationHookResult = ReturnType<
  typeof useEditSiteUserMutation
>
export type EditSiteUserMutationResult =
  Apollo.MutationResult<EditSiteUserMutation>
export type EditSiteUserMutationOptions = Apollo.BaseMutationOptions<
  EditSiteUserMutation,
  EditSiteUserMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser {
    deleteUser
  }
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const EditUserDocument = gql`
  mutation editUser($data: EditUserInput) {
    editUser(data: $data) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export type EditUserMutationFn = Apollo.MutationFunction<
  EditUserMutation,
  EditUserMutationVariables
>

/**
 * __useEditUserMutation__
 *
 * To run a mutation, you first call `useEditUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editUserMutation, { data, loading, error }] = useEditUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditUserMutation,
    EditUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditUserMutation, EditUserMutationVariables>(
    EditUserDocument,
    options
  )
}
export type EditUserMutationHookResult = ReturnType<typeof useEditUserMutation>
export type EditUserMutationResult = Apollo.MutationResult<EditUserMutation>
export type EditUserMutationOptions = Apollo.BaseMutationOptions<
  EditUserMutation,
  EditUserMutationVariables
>
export const SetUserApiKeyDocument = gql`
  mutation setUserApiKey($data: SetUserApiKeyInput) {
    setUserApiKey(data: $data) {
      ...UserApiKey
    }
  }
  ${UserApiKeyFragmentDoc}
`
export type SetUserApiKeyMutationFn = Apollo.MutationFunction<
  SetUserApiKeyMutation,
  SetUserApiKeyMutationVariables
>

/**
 * __useSetUserApiKeyMutation__
 *
 * To run a mutation, you first call `useSetUserApiKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserApiKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserApiKeyMutation, { data, loading, error }] = useSetUserApiKeyMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSetUserApiKeyMutation(
  baseOptions?: Apollo.MutationHookOptions<
    SetUserApiKeyMutation,
    SetUserApiKeyMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    SetUserApiKeyMutation,
    SetUserApiKeyMutationVariables
  >(SetUserApiKeyDocument, options)
}
export type SetUserApiKeyMutationHookResult = ReturnType<
  typeof useSetUserApiKeyMutation
>
export type SetUserApiKeyMutationResult =
  Apollo.MutationResult<SetUserApiKeyMutation>
export type SetUserApiKeyMutationOptions = Apollo.BaseMutationOptions<
  SetUserApiKeyMutation,
  SetUserApiKeyMutationVariables
>
export const GetBookmarksDocument = gql`
  query getBookmarks($first: Int, $after: String, $filter: BookmarkFilter) {
    bookmarks(first: $first, after: $after, filter: $filter) {
      ...BookmarksConnection
    }
  }
  ${BookmarksConnectionFragmentDoc}
`

/**
 * __useGetBookmarksQuery__
 *
 * To run a query within a React component, call `useGetBookmarksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetBookmarksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export function useGetBookmarksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export function useGetBookmarksSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export type GetBookmarksQueryHookResult = ReturnType<
  typeof useGetBookmarksQuery
>
export type GetBookmarksLazyQueryHookResult = ReturnType<
  typeof useGetBookmarksLazyQuery
>
export type GetBookmarksSuspenseQueryHookResult = ReturnType<
  typeof useGetBookmarksSuspenseQuery
>
export type GetBookmarksQueryResult = Apollo.QueryResult<
  GetBookmarksQuery,
  GetBookmarksQueryVariables
>
export const GetBookmarkDocument = gql`
  query getBookmark($id: ID!) {
    bookmark(id: $id) {
      ...BookmarkDetail
    }
  }
  ${BookmarkDetailFragmentDoc}
`

/**
 * __useGetBookmarkQuery__
 *
 * To run a query within a React component, call `useGetBookmarkQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarkQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBookmarkQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  > &
    (
      | { variables: GetBookmarkQueryVariables; skip?: boolean }
      | { skip: boolean }
    )
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export function useGetBookmarkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export function useGetBookmarkSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export type GetBookmarkQueryHookResult = ReturnType<typeof useGetBookmarkQuery>
export type GetBookmarkLazyQueryHookResult = ReturnType<
  typeof useGetBookmarkLazyQuery
>
export type GetBookmarkSuspenseQueryHookResult = ReturnType<
  typeof useGetBookmarkSuspenseQuery
>
export type GetBookmarkQueryResult = Apollo.QueryResult<
  GetBookmarkQuery,
  GetBookmarkQueryVariables
>
export const GetCommentsDocument = gql`
  query getComments($refId: ID!, $type: CommentType!) {
    comments(refId: $refId, type: $type) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`

/**
 * __useGetCommentsQuery__
 *
 * To run a query within a React component, call `useGetCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCommentsQuery({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCommentsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  > &
    (
      | { variables: GetCommentsQueryVariables; skip?: boolean }
      | { skip: boolean }
    )
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export type GetCommentsQueryHookResult = ReturnType<typeof useGetCommentsQuery>
export type GetCommentsLazyQueryHookResult = ReturnType<
  typeof useGetCommentsLazyQuery
>
export type GetCommentsSuspenseQueryHookResult = ReturnType<
  typeof useGetCommentsSuspenseQuery
>
export type GetCommentsQueryResult = Apollo.QueryResult<
  GetCommentsQuery,
  GetCommentsQueryVariables
>
export const GetEmailSubscriptionsDocument = gql`
  query getEmailSubscriptions($first: Int, $after: String) {
    emailSubscriptions(first: $first, after: $after) {
      ...EmailSubscriptionsConnection
    }
  }
  ${EmailSubscriptionsConnectionFragmentDoc}
`

/**
 * __useGetEmailSubscriptionsQuery__
 *
 * To run a query within a React component, call `useGetEmailSubscriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEmailSubscriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEmailSubscriptionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetEmailSubscriptionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >(GetEmailSubscriptionsDocument, options)
}
export function useGetEmailSubscriptionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >(GetEmailSubscriptionsDocument, options)
}
export function useGetEmailSubscriptionsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    GetEmailSubscriptionsQuery,
    GetEmailSubscriptionsQueryVariables
  >(GetEmailSubscriptionsDocument, options)
}
export type GetEmailSubscriptionsQueryHookResult = ReturnType<
  typeof useGetEmailSubscriptionsQuery
>
export type GetEmailSubscriptionsLazyQueryHookResult = ReturnType<
  typeof useGetEmailSubscriptionsLazyQuery
>
export type GetEmailSubscriptionsSuspenseQueryHookResult = ReturnType<
  typeof useGetEmailSubscriptionsSuspenseQuery
>
export type GetEmailSubscriptionsQueryResult = Apollo.QueryResult<
  GetEmailSubscriptionsQuery,
  GetEmailSubscriptionsQueryVariables
>
export const GetPagesDocument = gql`
  query getPages($filter: PagesFilter) {
    pages(filter: $filter) {
      ...PageListItem
    }
  }
  ${PageListItemFragmentDoc}
`

/**
 * __useGetPagesQuery__
 *
 * To run a query within a React component, call `useGetPagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPagesQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetPagesQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPagesQuery, GetPagesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPagesQuery, GetPagesQueryVariables>(
    GetPagesDocument,
    options
  )
}
export function useGetPagesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPagesQuery,
    GetPagesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPagesQuery, GetPagesQueryVariables>(
    GetPagesDocument,
    options
  )
}
export function useGetPagesSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetPagesQuery,
    GetPagesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetPagesQuery, GetPagesQueryVariables>(
    GetPagesDocument,
    options
  )
}
export type GetPagesQueryHookResult = ReturnType<typeof useGetPagesQuery>
export type GetPagesLazyQueryHookResult = ReturnType<
  typeof useGetPagesLazyQuery
>
export type GetPagesSuspenseQueryHookResult = ReturnType<
  typeof useGetPagesSuspenseQuery
>
export type GetPagesQueryResult = Apollo.QueryResult<
  GetPagesQuery,
  GetPagesQueryVariables
>
export const GetPageDocument = gql`
  query getPage($slug: String!) {
    page(slug: $slug) {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`

/**
 * __useGetPageQuery__
 *
 * To run a query within a React component, call `useGetPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPageQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPageQuery(
  baseOptions: Apollo.QueryHookOptions<GetPageQuery, GetPageQueryVariables> &
    ({ variables: GetPageQueryVariables; skip?: boolean } | { skip: boolean })
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPageQuery, GetPageQueryVariables>(
    GetPageDocument,
    options
  )
}
export function useGetPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPageQuery, GetPageQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPageQuery, GetPageQueryVariables>(
    GetPageDocument,
    options
  )
}
export function useGetPageSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetPageQuery,
    GetPageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetPageQuery, GetPageQueryVariables>(
    GetPageDocument,
    options
  )
}
export type GetPageQueryHookResult = ReturnType<typeof useGetPageQuery>
export type GetPageLazyQueryHookResult = ReturnType<typeof useGetPageLazyQuery>
export type GetPageSuspenseQueryHookResult = ReturnType<
  typeof useGetPageSuspenseQuery
>
export type GetPageQueryResult = Apollo.QueryResult<
  GetPageQuery,
  GetPageQueryVariables
>
export const GetHomePageDocument = gql`
  query getHomePage {
    homepage {
      ...PageDetail
    }
  }
  ${PageDetailFragmentDoc}
`

/**
 * __useGetHomePageQuery__
 *
 * To run a query within a React component, call `useGetHomePageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHomePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHomePageQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetHomePageQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetHomePageQuery,
    GetHomePageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetHomePageQuery, GetHomePageQueryVariables>(
    GetHomePageDocument,
    options
  )
}
export function useGetHomePageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetHomePageQuery,
    GetHomePageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetHomePageQuery, GetHomePageQueryVariables>(
    GetHomePageDocument,
    options
  )
}
export function useGetHomePageSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetHomePageQuery,
    GetHomePageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetHomePageQuery, GetHomePageQueryVariables>(
    GetHomePageDocument,
    options
  )
}
export type GetHomePageQueryHookResult = ReturnType<typeof useGetHomePageQuery>
export type GetHomePageLazyQueryHookResult = ReturnType<
  typeof useGetHomePageLazyQuery
>
export type GetHomePageSuspenseQueryHookResult = ReturnType<
  typeof useGetHomePageSuspenseQuery
>
export type GetHomePageQueryResult = Apollo.QueryResult<
  GetHomePageQuery,
  GetHomePageQueryVariables
>
export const GetPostsDocument = gql`
  query getPosts($filter: WritingFilter) {
    posts(filter: $filter) {
      ...PostListItem
    }
  }
  ${PostListItemFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsSuspenseQueryHookResult = ReturnType<
  typeof useGetPostsSuspenseQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetPostDocument = gql`
  query getPost($slug: String!) {
    post(slug: $slug) {
      ...PostDetail
    }
  }
  ${PostDetailFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables> &
    ({ variables: GetPostQueryVariables; skip?: boolean } | { skip: boolean })
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetPostQuery,
    GetPostQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostSuspenseQueryHookResult = ReturnType<
  typeof useGetPostSuspenseQuery
>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetQuestionsDocument = gql`
  query getQuestions($first: Int, $after: String, $filter: QuestionFilter) {
    questions(first: $first, after: $after, filter: $filter) {
      ...QuestionsConnection
    }
  }
  ${QuestionsConnectionFragmentDoc}
`

/**
 * __useGetQuestionsQuery__
 *
 * To run a query within a React component, call `useGetQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export function useGetQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export function useGetQuestionsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export type GetQuestionsQueryHookResult = ReturnType<
  typeof useGetQuestionsQuery
>
export type GetQuestionsLazyQueryHookResult = ReturnType<
  typeof useGetQuestionsLazyQuery
>
export type GetQuestionsSuspenseQueryHookResult = ReturnType<
  typeof useGetQuestionsSuspenseQuery
>
export type GetQuestionsQueryResult = Apollo.QueryResult<
  GetQuestionsQuery,
  GetQuestionsQueryVariables
>
export const GetQuestionDocument = gql`
  query getQuestion($id: ID!) {
    question(id: $id) {
      ...QuestionDetail
    }
  }
  ${QuestionDetailFragmentDoc}
`

/**
 * __useGetQuestionQuery__
 *
 * To run a query within a React component, call `useGetQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetQuestionQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  > &
    (
      | { variables: GetQuestionQueryVariables; skip?: boolean }
      | { skip: boolean }
    )
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export function useGetQuestionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export function useGetQuestionSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export type GetQuestionQueryHookResult = ReturnType<typeof useGetQuestionQuery>
export type GetQuestionLazyQueryHookResult = ReturnType<
  typeof useGetQuestionLazyQuery
>
export type GetQuestionSuspenseQueryHookResult = ReturnType<
  typeof useGetQuestionSuspenseQuery
>
export type GetQuestionQueryResult = Apollo.QueryResult<
  GetQuestionQuery,
  GetQuestionQueryVariables
>
export const GetSiteSettingsDocument = gql`
  query getSiteSettings {
    siteSettings {
      ...SiteEditInfo
    }
  }
  ${SiteEditInfoFragmentDoc}
`

/**
 * __useGetSiteSettingsQuery__
 *
 * To run a query within a React component, call `useGetSiteSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSiteSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSiteSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSiteSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetSiteSettingsQuery,
    GetSiteSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSiteSettingsQuery, GetSiteSettingsQueryVariables>(
    GetSiteSettingsDocument,
    options
  )
}
export function useGetSiteSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSiteSettingsQuery,
    GetSiteSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetSiteSettingsQuery,
    GetSiteSettingsQueryVariables
  >(GetSiteSettingsDocument, options)
}
export function useGetSiteSettingsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetSiteSettingsQuery,
    GetSiteSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    GetSiteSettingsQuery,
    GetSiteSettingsQueryVariables
  >(GetSiteSettingsDocument, options)
}
export type GetSiteSettingsQueryHookResult = ReturnType<
  typeof useGetSiteSettingsQuery
>
export type GetSiteSettingsLazyQueryHookResult = ReturnType<
  typeof useGetSiteSettingsLazyQuery
>
export type GetSiteSettingsSuspenseQueryHookResult = ReturnType<
  typeof useGetSiteSettingsSuspenseQuery
>
export type GetSiteSettingsQueryResult = Apollo.QueryResult<
  GetSiteSettingsQuery,
  GetSiteSettingsQueryVariables
>
export const GetUserSitesDocument = gql`
  query getUserSites {
    userSites {
      ...UserSiteInfo
    }
  }
  ${UserSiteInfoFragmentDoc}
`

/**
 * __useGetUserSitesQuery__
 *
 * To run a query within a React component, call `useGetUserSitesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserSitesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserSitesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUserSitesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetUserSitesQuery,
    GetUserSitesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserSitesQuery, GetUserSitesQueryVariables>(
    GetUserSitesDocument,
    options
  )
}
export function useGetUserSitesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetUserSitesQuery,
    GetUserSitesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserSitesQuery, GetUserSitesQueryVariables>(
    GetUserSitesDocument,
    options
  )
}
export function useGetUserSitesSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetUserSitesQuery,
    GetUserSitesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetUserSitesQuery, GetUserSitesQueryVariables>(
    GetUserSitesDocument,
    options
  )
}
export type GetUserSitesQueryHookResult = ReturnType<
  typeof useGetUserSitesQuery
>
export type GetUserSitesLazyQueryHookResult = ReturnType<
  typeof useGetUserSitesLazyQuery
>
export type GetUserSitesSuspenseQueryHookResult = ReturnType<
  typeof useGetUserSitesSuspenseQuery
>
export type GetUserSitesQueryResult = Apollo.QueryResult<
  GetUserSitesQuery,
  GetUserSitesQueryVariables
>
export const GetSiteUsersDocument = gql`
  query getSiteUsers {
    siteUsers {
      ...SiteUserInfo
    }
  }
  ${SiteUserInfoFragmentDoc}
`

/**
 * __useGetSiteUsersQuery__
 *
 * To run a query within a React component, call `useGetSiteUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSiteUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSiteUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSiteUsersQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetSiteUsersQuery,
    GetSiteUsersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSiteUsersQuery, GetSiteUsersQueryVariables>(
    GetSiteUsersDocument,
    options
  )
}
export function useGetSiteUsersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSiteUsersQuery,
    GetSiteUsersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSiteUsersQuery, GetSiteUsersQueryVariables>(
    GetSiteUsersDocument,
    options
  )
}
export function useGetSiteUsersSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetSiteUsersQuery,
    GetSiteUsersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetSiteUsersQuery, GetSiteUsersQueryVariables>(
    GetSiteUsersDocument,
    options
  )
}
export type GetSiteUsersQueryHookResult = ReturnType<
  typeof useGetSiteUsersQuery
>
export type GetSiteUsersLazyQueryHookResult = ReturnType<
  typeof useGetSiteUsersLazyQuery
>
export type GetSiteUsersSuspenseQueryHookResult = ReturnType<
  typeof useGetSiteUsersSuspenseQuery
>
export type GetSiteUsersQueryResult = Apollo.QueryResult<
  GetSiteUsersQuery,
  GetSiteUsersQueryVariables
>
export const GetTagsDocument = gql`
  query getTags {
    tags {
      name
    }
  }
`

/**
 * __useGetTagsQuery__
 *
 * To run a query within a React component, call `useGetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTagsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTagsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export function useGetTagsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export function useGetTagsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetTagsQuery,
    GetTagsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export type GetTagsQueryHookResult = ReturnType<typeof useGetTagsQuery>
export type GetTagsLazyQueryHookResult = ReturnType<typeof useGetTagsLazyQuery>
export type GetTagsSuspenseQueryHookResult = ReturnType<
  typeof useGetTagsSuspenseQuery
>
export type GetTagsQueryResult = Apollo.QueryResult<
  GetTagsQuery,
  GetTagsQueryVariables
>
export const GetUserDocument = gql`
  query getUser($username: String!) {
    user(username: $username) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables> &
    ({ variables: GetUserQueryVariables; skip?: boolean } | { skip: boolean })
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetUserQuery,
    GetUserQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserSuspenseQueryHookResult = ReturnType<
  typeof useGetUserSuspenseQuery
>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
export const GetViewerWithSettingsDocument = gql`
  query getViewerWithSettings {
    context {
      viewer {
        ...UserInfo
        email
        ...UserSettings
        ...UserApiKey
      }
    }
  }
  ${UserInfoFragmentDoc}
  ${UserSettingsFragmentDoc}
  ${UserApiKeyFragmentDoc}
`

/**
 * __useGetViewerWithSettingsQuery__
 *
 * To run a query within a React component, call `useGetViewerWithSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetViewerWithSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetViewerWithSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetViewerWithSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export function useGetViewerWithSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export function useGetViewerWithSettingsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export type GetViewerWithSettingsQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsQuery
>
export type GetViewerWithSettingsLazyQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsLazyQuery
>
export type GetViewerWithSettingsSuspenseQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsSuspenseQuery
>
export type GetViewerWithSettingsQueryResult = Apollo.QueryResult<
  GetViewerWithSettingsQuery,
  GetViewerWithSettingsQueryVariables
>
export const ContextDocument = gql`
  query context {
    context {
      viewer {
        ...UserInfo
        email
      }
      site {
        ...SitePublicInfo
      }
      userSite {
        ...UserSite
      }
      owner {
        image
        avatar
        hasEmail
        name
      }
    }
  }
  ${UserInfoFragmentDoc}
  ${SitePublicInfoFragmentDoc}
  ${UserSiteFragmentDoc}
`

/**
 * __useContextQuery__
 *
 * To run a query within a React component, call `useContextQuery` and pass it any options that fit your needs.
 * When your component renders, `useContextQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContextQuery({
 *   variables: {
 *   },
 * });
 */
export function useContextQuery(
  baseOptions?: Apollo.QueryHookOptions<ContextQuery, ContextQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ContextQuery, ContextQueryVariables>(
    ContextDocument,
    options
  )
}
export function useContextLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ContextQuery, ContextQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ContextQuery, ContextQueryVariables>(
    ContextDocument,
    options
  )
}
export function useContextSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    ContextQuery,
    ContextQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<ContextQuery, ContextQueryVariables>(
    ContextDocument,
    options
  )
}
export type ContextQueryHookResult = ReturnType<typeof useContextQuery>
export type ContextLazyQueryHookResult = ReturnType<typeof useContextLazyQuery>
export type ContextSuspenseQueryHookResult = ReturnType<
  typeof useContextSuspenseQuery
>
export type ContextQueryResult = Apollo.QueryResult<
  ContextQuery,
  ContextQueryVariables
>
